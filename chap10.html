

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Chapter 10: Build an Index &#8212; Computational Thinking and Problem Solving</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'chap10';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Chapter 11: Discover Driving Directions" href="chap11.html" />
    <link rel="prev" title="Chapter 9: Find a Phrase" href="chap09.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="welcome.html">
  
  
  
  
    
    
      
    
    
    <img src="_static/mike_flat.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="_static/mike_flat.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="welcome.html">
                    A Welcome
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="chap01.html">Chapter 1: Read a Children’s Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap02.html">Chapter 2: Grab the Dialogue</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap03.html">Chapter 3: Replace Text With Emoji</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap04.html">Chapter 4: Query a Web Resource</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap05.html">Chapter 5: Play Guess-a-number with a Friend</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap06.html">Chapter 6: Do You See My Dog?</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap07.html">Chapter 7: Many Numbers But Not Any Number</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap08.html">Chapter 8: What Is My Problem?</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap09.html">Chapter 9: Find a Phrase</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Chapter 10: Build an Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap11.html">Chapter 11: Discover Driving Directions</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap12.html">Chapter 12: Divide and Conquer</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap13.html">Chapter 13: Rewrite the Error Messages</a></li>
<li class="toctree-l1"><a class="reference internal" href="ales.html">Active-Learning Exercises</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/chap10.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Chapter 10: Build an Index</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#strings-to-numbers">Strings to numbers</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-simple-hash-function">A simple hash function</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#updating-a-hash-with-o-1-work">Updating a hash with O(1) work</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#allow-collisions">Allow collisions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#other-applications-of-hashing">Other applications of hashing</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#indices-for-fast-data-retrieval">Indices for fast data retrieval</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#hash-tables">Hash tables</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-speed-of-array-index-operations">The speed of array-index operations</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#with-high-probability">With high probability</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#collision-resolution">Collision resolution</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#specification-for-creating-a-book-index">Specification for creating a book index</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#building-top-down">Building top-down</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#updating-the-index">Updating the index</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#sort-and-strip">Sort and strip</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="chapter-10-build-an-index">
<h1>Chapter 10: Build an Index<a class="headerlink" href="#chapter-10-build-an-index" title="Permalink to this heading">#</a></h1>
<p>We discovered in the last chapter that the choice of algorithm can make a huge difference in the running time of our script as the size of our problem grows. Or stated more bluntly, a brute-force approach doesn’t work in all contexts. Under some especially stressful conditions, it fails spectacularly to deliver an answer in a reasonable amount of time.</p>
<p>This chapter opens with a description of how the Rabin-Karp algorithm avoids spectacular failure and the specific steps it takes to turn string-matching into a process that often grows only in proportion to the size of the text, not the size of the text times the size of the search string.</p>
<p>This knowledge introduces you to a new approach to problem solving. The approach still has us search the entire problem space for a solution, but it splits this search work into what is called <em>online and offline work</em>. When time from user input to solution matters, as it does in the Google search context, doing some of the work before a user gets involved (i.e., the offline work) and then the final bits of the work once we receive the user’s input (i.e., the online work) can mean the difference between meeting a problem’s requirements and spectacularly missing them.</p>
<p>Given the enormous size of the Google search problem, this sort of problem-solving approach is what we need to bypass the challenge that even a string-matching search that scans through the text only once, and does so on a really fast machine, cannot scan 100 million gigabytes with any response time that a human would find reasonable. In other words, linear-time string matching won’t solve our simplified Google search problem, and we need something else.</p>
<p>Fortunately, Rabin-Karp provides us with a potential answer. It introduces us to the technique of <em>hashing</em>, which allows us to build offline an index (like a book index) of the webpages that contain words of interest. But when we split the work we do to solve the problem into online and offline components, we have created for ourselves a new challenge: how do we know what to search for before the user asks us a question? Obviously, we don’t, but we can turn the preprocessing into work not just for one query, but (effectively) for all possible queries. This is what Google means when it talks about building an index. So our problem-to-be-solved becomes: <em>how do we build a book index?</em> A book index is simpler than Google’s web index, but the online performance of an index is what we need to solve our simplified Google search problem!</p>
<div class="admonition-learning-outcomes admonition">
<p class="admonition-title">Learning Outcomes</p>
<p>In this chapter, you will learn a new approach to problem solving that splits work into online and offline components. You will build a book index, which is a simplified version of Google’s search index, using hash functions and hash tables, and distinguish common and exceptional situations though a discussion of hash collisions. By the end of the chapter, you will be able to:</p>
<ul class="simple">
<li><p>Understand how hashing is the key to solving the Google search problem [design and CS concepts];</p></li>
<li><p>Design a simple hash function [design and programming skills];</p></li>
<li><p>Handle hash collisions in a solution that uses hashing [CS concepts and programming skills];</p></li>
<li><p>Describe other applications where hashing proves effective [design];</p></li>
<li><p>Discuss the operation of a hash table and explain how it achieves its performance [CS concepts];</p></li>
<li><p>Distinguish between an abstract data type, such as an associative memory, and concrete data types, like the Python dictionary type [CS concepts];</p></li>
<li><p>Understand the basic operation of random-access memories [CS concepts];</p></li>
<li><p>Recognize how the distinction between common and exceptional situations can lead to effective designs, as in how collisions are resolved in hash tables [design].</p></li>
</ul>
</div>
<section id="strings-to-numbers">
<p><strong>Strings to numbers.</strong> To understand the brilliance of the Rabin-Karp algorithm, let’s begin with a focus on the matching loop. This is what that loop looked like in <code class="docutils literal notranslate"><span class="pre">bf_strmatch</span></code>, given a pattern string <code class="docutils literal notranslate"><span class="pre">p</span></code> of length <code class="docutils literal notranslate"><span class="pre">m</span></code> and a text string <code class="docutils literal notranslate"><span class="pre">t</span></code> of length <code class="docutils literal notranslate"><span class="pre">n</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">10</span><span class="c1">### Part of chap09/bf_strmatch.py -- not executable</span>
<span class="linenos">11</span><span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
<span class="linenos">12</span>    <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="n">m</span><span class="p">]:</span>
<span class="linenos">13</span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Pattern occurs with shift </span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This loop has a computational complexity of <span class="math notranslate nohighlight">\(O((n-m+1)*m)\)</span> because it makes up to <em>m</em> character comparisons on every iteration of the for-loop. In <code class="docutils literal notranslate"><span class="pre">rk_strmatch</span></code>, we turned the if-statement from one hiding a loop up to <em>m</em>, which has a computational complexity cost of <span class="math notranslate nohighlight">\(O(m)\)</span>, into an equality comparison between two integers (line 43 in <code class="docutils literal notranslate"><span class="pre">chap09/rk_strmatch.py</span></code>), which has a computational complexity cost of <span class="math notranslate nohighlight">\(O(1)\)</span>.</p>
<p>It’s important to realize that the equality comparison is answering the pseudocode question: Does the pattern string match the text substring of length <code class="docutils literal notranslate"><span class="pre">m</span></code> starting at character location <code class="docutils literal notranslate"><span class="pre">s</span></code>? You are probably now asking the question: How does a single integer hold the same information content as a string of length <code class="docutils literal notranslate"><span class="pre">m</span></code>?</p>
</section>
<section id="a-simple-hash-function">
<p><strong>A simple hash function.</strong> We call these integers <em>hashes</em> of their corresponding strings, and the specification for computing a hash looks something like the following: <em>Given a string of arbitrary length, use the string’s encoding to compute an integer.</em> This specification, illustrated in <a class="reference internal" href="#c10-fig1-ref"><span class="std std-numref">Figure 17</span></a>, is a bit simpler than what we’ll discover we need, but it is enough to get us started.</p>
<figure class="align-default" id="c10-fig1-ref">
<img alt="_images/c10_fig1.png" src="_images/c10_fig1.png" />
<figcaption>
<p><span class="caption-number">Fig. 17 </span><span class="caption-text">To create a hash, which is just an integer value, we’ll write a function that takes a string of any length as input and returns an integer.</span><a class="headerlink" href="#c10-fig1-ref" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>How might we algorithmically create a hash from a string? First, remember that every character has a unique numerical encoding, and when we’re working with strings, we were just interpreting each number as a character. To create an integer hash that has some relationship to the characters in a string, we’ll want to get access to the characters’ numerical encodings, which we can do by using Python’s built-in <code class="docutils literal notranslate"><span class="pre">ord</span></code> function.</p>
<aside class="margin sidebar">
<p class="sidebar-title">Simplification</p>
<p>We use <a class="reference external" href="https://home.unicode.org/">Unicode</a> to give us an encoding space big enough to capture many of the different characters used in human communication. Without loss of generality and to simplify my examples, I’ll won’t use Unicode and instead use the older ASCII encoding, which encodes the characters in 8 bits or 1 byte.</p>
</aside>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Knowing this, one way to create a hash function would be to read the input string as a sequence of digits, where each digit in the number output from the hash function is the ASCII encoding of the character at that digit’s location. This is probably easier to understand through an example.</p>
<p>For a moment, let’s pretend that <code class="docutils literal notranslate"><span class="pre">ord('1')</span></code> is not <code class="docutils literal notranslate"><span class="pre">49</span></code>, but <code class="docutils literal notranslate"><span class="pre">1</span></code>. In fact, let’s assume every character digit between 0 and 9 has itself as its numerical encoding. What then is the hash of the string <code class="docutils literal notranslate"><span class="pre">'1983'</span></code>? It’s just the number 1 followed by the number 9 followed by 8 and finally 3. Read together as a single number <code class="docutils literal notranslate"><span class="pre">1983</span></code>, these digits represent the number one thousand nine hundred and eighty-three.</p>
<p>Following this same logic with ASCII, in which each digit’s encoding doesn’t fit in a single base-10 digit but requires a base-256 digit (i.e., the encoding is 8-bits wide), <code class="docutils literal notranslate"><span class="pre">'1983'</span></code> becomes the number 49 followed by the number 57 followed by 56 and finally 51. Thinking about each of these digits in base-256 and then converting that number to base-10, the hash of <code class="docutils literal notranslate"><span class="pre">'1983'</span></code> is:</p>
<p><span class="math notranslate nohighlight">\(((49 * 256 + 57) * 256 + 56) * 256 + 51 = 825,833,523\)</span></p>
<p>You can experiment with this hashing algorithm using the following Python function called <code class="docutils literal notranslate"><span class="pre">simple_hash</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">### chap10/simple_hash.py</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="k">def</span> <span class="nf">simple_hash</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="linenos"> 4</span>    <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
<span class="linenos"> 5</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
<span class="linenos"> 6</span>        <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="mi">256</span> <span class="o">+</span> <span class="nb">ord</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="linenos"> 7</span>    <span class="k">return</span> <span class="n">num</span>
<span class="linenos"> 8</span>
<span class="linenos"> 9</span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;1983&#39;</span>
<span class="linenos">10</span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s1"> = </span><span class="si">{</span><span class="n">simple_hash</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="updating-a-hash-with-o-1-work">
<p><strong>Updating a hash with O(1) work.</strong> There’s a problem with this simple approach, which we’ll get to in a moment, but let’s first return to Rabin-Karp. Inside the matching loop, it uses the if-statement to compare the hash for the pattern string against a hash of an <code class="docutils literal notranslate"><span class="pre">m</span></code>-character substring of the text string. We could use <code class="docutils literal notranslate"><span class="pre">simple_hash</span></code> to calculate the hash of the pattern string without affecting our goal computational complexity measure because the pattern string remains the same for the entire execution of the matching loop. It is a value that is called <em>loop invariant</em>, and as such, we can compute the hash of the pattern string before we enter the matching loop. This is exactly one of the <span class="math notranslate nohighlight">\(O(m)\)</span> terms we noticed in the last chapter in the pre-processing code of <code class="docutils literal notranslate"><span class="pre">rk_strmatch</span></code>.</p>
<p>But what about the substring of text to which we compare the pattern string? It changes from one iteration of the matching loop to the next. Luckily, there’s a very simply pattern to how it changes.</p>
<p>To understand this pattern, first recognize that the matching loop begins with the first <span class="math notranslate nohighlight">\(m\)</span> characters of the text string. As we did with the pattern string, we can compute the text string’s starting hash before we enter the matching loop. It falls under the same <span class="math notranslate nohighlight">\(O(m)\)</span> term that computed the pattern string’s hash since both can be done within the same preprocessing loop.</p>
<p>Then comes the repeating pattern: Given a text substring of <span class="math notranslate nohighlight">\(m\)</span> characters, the next substring to consider removes the leftmost character in the substring and adds a new character to the righthand side of the substring. This action corresponds to the sliding of the pattern-string template one character to the right for each matching loop iteration, as shown in <a class="reference internal" href="#c10-fig2-ref"><span class="std std-numref">Figure 18</span></a>.</p>
<figure class="align-default" id="c10-fig2-ref">
<img alt="_images/c10_fig2.png" src="_images/c10_fig2.png" />
<figcaption>
<p><span class="caption-number">Fig. 18 </span><span class="caption-text">To update a hash, our script must do three things: (1) remove the most significant digit; (2) shift up by one digit the significance of the remaining digits; and (3) add in a new least significant digit.</span><a class="headerlink" href="#c10-fig2-ref" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Knowing this, how do we numerically adjust our simple hash knowing that we have to slice off the most-significant digit, shift the remaining digits, and append a new least-significant digit? Well, in the make-believe world where ASCII characters <code class="docutils literal notranslate"><span class="pre">'0'</span></code> through <code class="docutils literal notranslate"><span class="pre">'9'</span></code> are encoded with their numerical values, we turn the hash for <code class="docutils literal notranslate"><span class="pre">'1983'</span></code> (i.e., <code class="docutils literal notranslate"><span class="pre">1983</span></code>) into the hash for <code class="docutils literal notranslate"><span class="pre">'9834'</span></code> (i.e., <code class="docutils literal notranslate"><span class="pre">9834</span></code>) in the following way:</p>
<p><span class="math notranslate nohighlight">\((1983 - (1 * 10^3)) * 10 + 4 = 9834\)</span></p>
<p>With real ASCII encodings and a pattern string of length <code class="docutils literal notranslate"><span class="pre">m</span></code>, the function <code class="docutils literal notranslate"><span class="pre">update_hash</span></code> implements this as an algorithm we can repeatedly use on each iteration of the matching loop. Please note that the function computes the magnitude of a one in the most-significant digit each time it is called, but this is also a fixed value once we know the size of the pattern string. As such, Rabin-Karp puts this calculation in its preprocessing code, which is the other <span class="math notranslate nohighlight">\(O(m-1)\)</span> computational complexity cost that we had computed for preprocessing.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 8</span><span class="c1">### chap10/simple_hash.py</span>
<span class="linenos"> 9</span><span class="k">def</span> <span class="nf">update_hash</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
<span class="linenos">10</span>    <span class="c1"># Magnitude of the most-significant digit</span>
<span class="linenos">11</span>    <span class="n">mag</span> <span class="o">=</span> <span class="mi">1</span>
<span class="linenos">12</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
<span class="linenos">13</span>        <span class="n">mag</span> <span class="o">*=</span> <span class="mi">256</span>
<span class="linenos">14</span>
<span class="linenos">15</span>    <span class="c1"># Take off most-significant digit</span>
<span class="linenos">16</span>    <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="o">*</span> <span class="n">mag</span>
<span class="linenos">17</span>
<span class="linenos">18</span>    <span class="c1"># Add on a new least-significant digit</span>
<span class="linenos">19</span>    <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="mi">256</span> <span class="o">+</span> <span class="nb">ord</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">s</span> <span class="o">+</span> <span class="n">m</span><span class="p">])</span>
<span class="linenos">20</span>
<span class="linenos">21</span>    <span class="k">return</span> <span class="n">num</span>
</pre></div>
</div>
<p>Let’s test this approach using an expansion of our running example.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">28</span><span class="c1">### chap10/simple_hash.py</span>
<span class="linenos">29</span><span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;77719834777&#39;</span>
<span class="linenos">30</span><span class="n">s</span> <span class="o">=</span> <span class="mi">3</span>    <span class="c1"># Pretend we&#39;re in the middle of the match loop</span>
<span class="linenos">31</span><span class="n">m</span> <span class="o">=</span> <span class="mi">4</span>    <span class="c1"># and the pattern string is 4 characters long</span>
<span class="linenos">32</span><span class="n">num</span> <span class="o">=</span> <span class="n">simple_hash</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="n">m</span><span class="p">])</span>
<span class="linenos">33</span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">text</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="n">m</span><span class="p">]</span><span class="si">}</span><span class="s1"> = </span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="linenos">34</span>
<span class="linenos">35</span><span class="n">num</span> <span class="o">=</span> <span class="n">update_hash</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
<span class="linenos">36</span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;updated hash = </span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="linenos">37</span>
<span class="linenos">38</span><span class="n">s</span> <span class="o">+=</span> <span class="mi">1</span>   <span class="c1"># Verify we got the right answer</span>
<span class="linenos">39</span><span class="n">num</span> <span class="o">=</span> <span class="n">simple_hash</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="n">m</span><span class="p">])</span>
<span class="linenos">40</span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">text</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="n">m</span><span class="p">]</span><span class="si">}</span><span class="s1"> = </span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The following block of code puts together what we’ve done to convert the original <code class="docutils literal notranslate"><span class="pre">bf_strmatch</span></code> code into something resembling the Rabin-Karp method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">def</span> <span class="nf">rk_strmatch_partial</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="linenos"> 2</span>    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="linenos"> 3</span>    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span>    <span class="c1"># Preprocessing steps</span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span>    <span class="c1"># Constants in Rabin-Karp string-matching problem</span>
<span class="linenos"> 8</span>    <span class="n">d</span> <span class="o">=</span> <span class="mi">256</span>    <span class="c1"># number of character encodings in ASCII</span>
<span class="linenos"> 9</span>
<span class="linenos">10</span>    <span class="c1"># Compute the hash value of a 1 in the high-order position (i.e.,</span>
<span class="linenos">11</span>    <span class="c1"># m-1th position), where digits have radix d</span>
<span class="linenos">12</span>    <span class="n">hh</span> <span class="o">=</span> <span class="mi">1</span>
<span class="linenos">13</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
<span class="linenos">14</span>        <span class="n">hh</span> <span class="o">=</span> <span class="n">hh</span> <span class="o">*</span> <span class="n">d</span>
<span class="linenos">15</span>
<span class="linenos">16</span>    <span class="c1"># Calculate the hash values for p and t[0:m], since the matching</span>
<span class="linenos">17</span>    <span class="c1"># loop needs these values as it starts</span>
<span class="linenos">18</span>    <span class="n">hp</span> <span class="o">=</span> <span class="mi">0</span>
<span class="linenos">19</span>    <span class="n">ht</span> <span class="o">=</span> <span class="mi">0</span>
<span class="linenos">20</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
<span class="linenos">21</span>        <span class="n">hp</span> <span class="o">=</span> <span class="p">(</span><span class="n">hp</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="nb">ord</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="linenos">22</span>        <span class="n">ht</span> <span class="o">=</span> <span class="p">(</span><span class="n">ht</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="nb">ord</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="linenos">23</span>
<span class="linenos">24</span>    <span class="c1"># Matching step</span>
<span class="linenos">25</span>    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
<span class="linenos">26</span>        <span class="k">if</span> <span class="n">hp</span> <span class="o">==</span> <span class="n">ht</span><span class="p">:</span>
<span class="linenos">27</span>            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Pattern occurs with shift </span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="linenos">28</span>
<span class="linenos">29</span>        <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span><span class="p">:</span>
<span class="linenos">30</span>            <span class="c1"># Need to compute hash for next iteration</span>
<span class="linenos">31</span>            <span class="n">ht</span> <span class="o">=</span> <span class="p">(</span><span class="n">ht</span> <span class="o">-</span> <span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="o">*</span> <span class="n">hh</span><span class="p">))</span> <span class="o">*</span> <span class="n">d</span> <span class="o">+</span> <span class="nb">ord</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="n">m</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="allow-collisions">
<p><strong>Allow collisions.</strong> The view is beautiful from up here, but Houston, we have a problem. This simple hashing function requires that the size of the space of hash numbers is the same as the size of the space of our pattern strings, which we’d like to be infinite. Let me make this size problem concrete for you with an example.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;one thousand nine hundred and eighty-three&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s1"> = </span><span class="si">{</span><span class="n">simple_hash</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Thank goodness Python doesn’t put a bound on the size of the integers it allows us to express! But we can’t pretend that this really big number is any less expensive to process than the original string. We need to update the specification for our hashing function.</p>
<p>We want a hash function that maps an arbitrary length string into a reasonably small range of numbers. By reasonable, I mean a set of numbers that require nothing more than a single machine operation in which to do an equality comparison. We don’t know much about machine operations at this point, but whatever we pick shouldn’t create too big a number when running the types of operations we have in <code class="docutils literal notranslate"><span class="pre">rk_strmatch_partial</span></code> above. Do you remember from the end of Act I that my machine could count pretty darn quick up to several billion? We’re probably safe if the results of the multiplications in <code class="docutils literal notranslate"><span class="pre">rk_strmatch_partial</span></code> don’t exceed this number.</p>
<aside class="margin sidebar">
<p class="sidebar-title">Modular Arithmetic</p>
<p>If you need a refresher on the rules in modular arithmetic, I recommend the <a class="reference external" href="https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/what-is-modular-arithmetic">tutorial in Khan Academy</a>.</p>
</aside>
<p>Ok, but the function <code class="docutils literal notranslate"><span class="pre">simple_hash</span></code> doesn’t just multiply a number by 256. It repeatedly multiples a number by 256 (then adds a little bit) for <code class="docutils literal notranslate"><span class="pre">m</span></code> iterations. We need something that correctly handles multiplication as an operation, but also puts a bound on the number of digits (really bits) that will be required to represent each result. By this point, you have probably guessed that we can use <em>modular arithmetic</em> to accomplish this goal.</p>
<p>We’re almost back to the implementation for <code class="docutils literal notranslate"><span class="pre">rk_strmatch</span></code> that we presented in the last chapter. We reprint it here so that you can more easily follow along with the final bits of the explanation.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">### chap10/rk_strmatch.py</span>
<span class="linenos"> 2</span><span class="k">def</span> <span class="nf">rk_strmatch</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="linenos"> 3</span>    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="linenos"> 4</span>    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span>    <span class="c1"># Preprocessing steps</span>
<span class="linenos"> 7</span>
<span class="linenos"> 8</span>    <span class="c1"># Constants in Rabin-Karp string-matching problem</span>
<span class="linenos"> 9</span>    <span class="n">d</span> <span class="o">=</span> <span class="mi">256</span>    <span class="c1"># number of character encodings in ASCII</span>
<span class="linenos">10</span>    <span class="n">q</span> <span class="o">=</span> <span class="mi">65537</span>  <span class="c1"># a prime number</span>
<span class="linenos">11</span>
<span class="linenos">12</span>    <span class="c1"># Compute the hash value of a 1 in the high-order position (i.e.,</span>
<span class="linenos">13</span>    <span class="c1"># m-1th position), where digits have radix d</span>
<span class="linenos">14</span>    <span class="n">hh</span> <span class="o">=</span> <span class="mi">1</span>
<span class="linenos">15</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
<span class="linenos">16</span>        <span class="n">hh</span> <span class="o">=</span> <span class="p">(</span><span class="n">hh</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span> <span class="o">%</span> <span class="n">q</span>
<span class="linenos">17</span>
<span class="linenos">18</span>    <span class="c1"># Calculate the hash values for p and t[0:m], since the matching</span>
<span class="linenos">19</span>    <span class="c1"># loop needs these values as it starts</span>
<span class="linenos">20</span>    <span class="n">hp</span> <span class="o">=</span> <span class="mi">0</span>
<span class="linenos">21</span>    <span class="n">ht</span> <span class="o">=</span> <span class="mi">0</span>
<span class="linenos">22</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
<span class="linenos">23</span>        <span class="n">hp</span> <span class="o">=</span> <span class="p">((</span><span class="n">hp</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="nb">ord</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">%</span> <span class="n">q</span>
<span class="linenos">24</span>        <span class="n">ht</span> <span class="o">=</span> <span class="p">((</span><span class="n">ht</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="nb">ord</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">%</span> <span class="n">q</span>
<span class="linenos">25</span>
<span class="linenos">26</span>    <span class="c1"># Matching step</span>
<span class="linenos">27</span>    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
<span class="linenos">28</span>        <span class="k">if</span> <span class="n">hp</span> <span class="o">==</span> <span class="n">ht</span><span class="p">:</span>
<span class="linenos">29</span>            <span class="c1"># Verify that this is an actual match</span>
<span class="linenos">30</span>            <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="n">m</span><span class="p">]:</span>
<span class="linenos">31</span>                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Pattern occurs with shift </span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="linenos">32</span>
<span class="linenos">33</span>        <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span><span class="p">:</span>
<span class="linenos">34</span>            <span class="c1"># Need to compute hash for next iteration</span>
<span class="linenos">35</span>            <span class="n">ht</span> <span class="o">=</span> <span class="p">((</span><span class="n">ht</span> <span class="o">-</span> <span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="o">*</span> <span class="n">hh</span><span class="p">))</span> <span class="o">*</span> <span class="n">d</span>
<span class="linenos">36</span>                  <span class="o">+</span> <span class="nb">ord</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="n">m</span><span class="p">]))</span> <span class="o">%</span> <span class="n">q</span>
<span class="linenos">37</span>            <span class="k">if</span> <span class="n">ht</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="linenos">38</span>                <span class="n">ht</span> <span class="o">+=</span> <span class="n">q</span>
</pre></div>
</div>
<aside class="margin sidebar">
<p class="sidebar-title">Human Languages</p>
<p>Human languages are, of course, not random in their distribution of letters and letter sequences. However, we do the best we can in not making the problem worse.</p>
</aside>
<p>In the preprocessing work for <code class="docutils literal notranslate"><span class="pre">rk_strmatch</span></code>, we set the variable <code class="docutils literal notranslate"><span class="pre">q</span></code> to the prime number <code class="docutils literal notranslate"><span class="pre">65537</span></code>. We could have used any prime number of reasonable size as the modulus for our modular arithmetic. The use of a prime modulus helps to more evenly spread the numbers generated by our hash function around the hash space. The actual spread depends on the strings you choose to hash at any particular time, but assuming some randomness in the input strings, a prime modulus helps pull that randomness into the hash space.</p>
<p>Let’s update our specification (see <a class="reference internal" href="#c10-fig3-ref"><span class="std std-numref">Figure 19</span></a>) with what we’ve done.</p>
<figure class="align-default" id="c10-fig3-ref">
<img alt="_images/c10_fig3.png" src="_images/c10_fig3.png" />
<figcaption>
<p><span class="caption-number">Fig. 19 </span><span class="caption-text">An updated specification for hashing that limits the range of integers produced. When two strings to map to the same integer, it’s called a hash collision (not shown).</span><a class="headerlink" href="#c10-fig3-ref" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Notice that it is entirely possible, although we hope infrequent, that two (or more) input strings will hash to the same number. This is called a <em>hash collision</em>. Hope, of course, is not a problem-solving strategy, and any code that uses hashes as a shorthand for arbitrary-length strings must check when two hashes match. In particular, we mush check that the two strings from which these hashes originated are in fact the same. If they aren’t, we simply found a <em>collision</em> in the hash space.</p>
<p>Handling collisions is the purpose of the if-statement on line 30. Notice that, when the algorithm encounters a lot of hash collisions, its behavior reverts back to the worst-case computational complexity of <code class="docutils literal notranslate"><span class="pre">bf_strmatch</span></code>.</p>
<p>You might wonder why the code only does something extra when it finds two hashes that match. What about the case when the two hashes don’t match? Will we ever have a problem? Absolutely not. When two hashes are different, then the strings from which they were generated must have been different.</p>
<p>In summary, using a hash function that does a good job of mapping arbitrary-length strings into a fixed range of numbers with few collisions will allow the running time of <code class="docutils literal notranslate"><span class="pre">rk_strmatch</span></code> to approximate <span class="math notranslate nohighlight">\(O(n)\)</span>.</p>
</section>
<section id="other-applications-of-hashing">
<p><strong>Other applications of hashing.</strong> We talked about hashing in the domain of string matching, and in particular as a way of creating a <em>fingerprint</em> or small summary of a large amount of data. Creating such fingerprints has been found to be broadly useful beyond string matching. For example, we might use hashing to create a fingerprint of a large block of data we wish to send across a computer network, and on which we know there is a non-zero probability that some bits might not be transmitted properly. While similar in concept to the string-matching problem we just discussed, this problem domain has different requirements.</p>
<p>In particular, in this problem domain we don’t need a function that produces hashes which we can incrementally update as we scan across the data. In a typical scenario, a sender scans the data once and produces a hash. This sender then sends both the data and its hash across the network to a receiver. When the receiver has all the data, it computes the hash of the data it received and compares this hash against the one sent by the sender. If the two match, it is highly probable that the data and the hash were transmitted without any errors. However, if the two hashes don’t match, the receiver knows that either the data or its hash was corrupted in transit, and it will request the sender to resend the data. Because we can’t rule out a transmission error, it is even more important in this problem domain than in string matching to reduce the probability of a collision. This is just one example of how different problem domains can influence the prioritization of the properties and metrics of your solution.</p>
<p>Although we know a lot about string matching now, we still haven’t found a solution to our simplified Google search problem that executes with a delay that a human would find acceptable. To actually solve this problem, we need to discuss yet another application of hashing.</p>
</section>
<section id="indices-for-fast-data-retrieval">
<p><strong>Indices for fast data retrieval.</strong> You know how a book index works: Given a keyword, you use the index to find a listing of the pages in the book that contain the keyword. We humans still have to search the book index for the keyword, but once we have found the entry, we are directly rewarded with the pages on which we can find the keyword. This is how you should think of Google’s search index. Google pulls from the string we type into its search box a set of keywords, and then it uses these keywords to quickly lookup in its index the webpages that contain them.</p>
<p>Of course, Google’s search index is going to contain a huge number of keywords as it indexes a huge number of webpages. How does Google quickly find the entry for our keywords among all the keywords in its index? You guessed it—through the power of hashing, as illustrated in <a class="reference internal" href="#c10-fig4-ref"><span class="std std-numref">Figure 20</span></a>.</p>
<figure class="align-default" id="c10-fig4-ref">
<img alt="_images/c10_fig4.png" src="_images/c10_fig4.png" />
<figcaption>
<p><span class="caption-number">Fig. 20 </span><span class="caption-text">A simplified diagram of how Google goes from a string in its search box to a listing of webpages containing one or more keywords from the string.</span><a class="headerlink" href="#c10-fig4-ref" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="hash-tables">
<p><strong>Hash tables.</strong> A hash function is a procedure that can turn the unbounded space of all strings into a bounded range of integers. Built on top of this procedure, a <em>hash table</em> is a data structure that associates a storage location with each integer that the hash function can produce. The hash function plus “search index” block in <a class="reference internal" href="#c10-fig4-ref"><span class="std std-numref">Figure 20</span></a> is an example of a hash table.</p>
<aside class="margin sidebar">
<p class="sidebar-title">Abstract Data Types</p>
<p>The adjective “abstract” emphasizes the fact that we aren’t expected to know anything about the implementation of this data type. We know about its function (i.e., its behavior), but nothing about its implementation or the runtime performance of its operations.</p>
</aside>
<p>Hash tables are also called <em>associative memories</em> or <em>associative arrays</em>. As an <em>abstract data type</em>, associative arrays support the mapping of keys to values. In Python, the dictionary data type (<code class="docutils literal notranslate"><span class="pre">dict</span></code>) is an associative memory built into the language. You may recall that we used this data type in Chapter 4 to associate the values we wanted with the keys that described a query string (e.g., the value <code class="docutils literal notranslate"><span class="pre">'json'</span></code> with the key <code class="docutils literal notranslate"><span class="pre">'format'</span></code>).</p>
<p>But hash tables are more than this abstraction; they are a <em>concrete data type</em> with specific run-time performance goals for its individual operations. You use a hash table when you want an associative array for which it takes a small amount of time to insert an item, delete an item, and search for an item. Stated in terms of computational complexity, each of these operations take <span class="math notranslate nohighlight">\(O(1)\)</span> time in a hash table.</p>
</section>
<section id="the-speed-of-array-index-operations">
<p><strong>The speed of array-index operations.</strong> You might be saying, “Wait? What’s going on behind this associative-memory abstraction that guarantees this performance?”</p>
<p>Let’s step back and recognize that the search-index data structure we drew in <a class="reference internal" href="#c10-fig4-ref"><span class="std std-numref">Figure 20</span></a> looks a lot like the sequences and arrays we drew in Act I. They were just a bunch of boxes placed one after the other, and we used the square-bracket syntax (<code class="docutils literal notranslate"><span class="pre">[]</span></code>) to say from which box’s contents we wanted. For example, if we wanted the fifth character in <code class="docutils literal notranslate"><span class="pre">the_line</span></code> we just read from <code class="docutils literal notranslate"><span class="pre">CatInTheHat.txt</span></code>, we got it by typing <code class="docutils literal notranslate"><span class="pre">the_line[4]</span></code>.</p>
<p>To this point, you probably haven’t thought about how long it takes your machine to grab the fifth character in a string like <code class="docutils literal notranslate"><span class="pre">the_line</span></code>. Does the machine start from the beginning of the string (i.e., <code class="docutils literal notranslate"><span class="pre">the_line[0]</span></code>) in the computer’s memory, count 5 characters forward, and then return the character at that fifth location? If it did, then every index into a string would take time proportional to its location in the string.</p>
<p>It clearly doesn’t, or I wouldn’t be raising this point. The beauty of our computers’ memories, where our scripts execute, are that they are <em>random-access memories (RAM) indexed by byte addresses</em>. In a random-access memory, if you present the memory with a byte address (i.e., an index measured in bytes from the start of the memory), it will immediately read that location and give you back what’s stored there (assuming that the address doesn’t exceed the memory’s size). There is no search involved; it is <em>direct access</em>.</p>
<p>Returning to our string example, to directly access a character in a string, the Python interpreter simply needs to know:</p>
<ol class="arabic simple">
<li><p>the address of where a string starts in memory (i.e., the byte address of its first character);</p></li>
<li><p>the size of a character in bytes in this string type (i.e., does the string just store 1-byte ASCII characters or something larger?), and</p></li>
<li><p>the index of the character the programmer wants (i.e., the number within the square brackets).</p></li>
</ol>
<p>The Python interpreter then multiplies the index by the size of a character and then adds this result to the starting address of the string to generate the address in memory where it can find the character you desire. A few quick pieces of simple math and the value is returned to you.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">byte_address</span> <span class="o">=</span> <span class="n">index</span> <span class="o">*</span> <span class="n">size_of</span><span class="p">(</span><span class="n">character</span><span class="p">)</span> <span class="o">+</span> <span class="n">starting_byte_address</span>
</pre></div>
</div>
<p>To implement a hash table with insertion, deletion, and search operations that execute in constant time, we create an array (let’s call it <code class="docutils literal notranslate"><span class="pre">hash_table</span></code>) as large as the hash space we need. Each location in this array will be a fixed number of bytes (let’s call it <code class="docutils literal notranslate"><span class="pre">sz</span></code>), which are large enough to hold the largest value we want associated with the hash table keys. Then when a script asks for <code class="docutils literal notranslate"><span class="pre">hash_table[5]</span></code>, for example, the code behind the hash table abstraction computes the memory address of the value we want by adding the address of <code class="docutils literal notranslate"><span class="pre">hash_table[0]</span></code> and 5 times <code class="docutils literal notranslate"><span class="pre">sz</span></code>. With this address, it directly accesses the memory location containing the value. Constant-time lookup. Insertion and deletion involve a similar set of operations.</p>
</section>
<section id="with-high-probability">
<p><strong>With high probability.</strong> A good hash table does two things: (1) computes hashes quickly and (2) minimizes the probability of a hash collision between two different inputs (e.g., keys in a Python dictionary). But because hash functions do not guarantee that the hashes for different inputs won’t collide, hash tables have to be able to determine which input is associated with the value stored at each table location. This requirement means that most hash-table implementations store both the value and the input (that was hashed) in a hash table entry. It is then easy to do the comparison check that avoids a wrong value being returned on a hash collision.</p>
<p>But this is where things get tricky. Let’s assume that our hash table uses strings as keys. How long does it take to do string matching to verify that the stored value is associated with the input key? Aargh! We know this. In the best case, it is proportional to the length of the string. If we do brute-force string matching during our hash table lookup, the computational complexity of the operation is not <span class="math notranslate nohighlight">\(O(1)\)</span>, but <span class="math notranslate nohighlight">\(O(sizeOfTheInputString)\)</span>.</p>
<p>This annoying wrinkle is why most hash table implementations, including <a class="reference external" href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries">dictionaries in Python</a>, require you to use immutable types for the hash table keys. Briefly, an object of an immutable type allows the Python interpreter to use the starting address of that object in memory as a small hash of the object. The cases we would need to enumerate to convince ourselves that this comparison would suffice to identify a hash collision would make this description even more tedious than it has already become. And luckily, we’re not here to build a working hash-table data type. We just want to use one and understand when we’ll get good performance from it.</p>
</section>
<section id="collision-resolution">
<p><strong>Collision resolution.</strong> As much as I’d like to end at this point and complete the design of our book index, I have to highlight one more detail that I glossed over in the preceding discussion: <em>What happens when we want to store two key-value pairs in our hash table where both keys hash to the same location in the hash table array?</em></p>
<p>Not allowing such a thing to happen would break the desired behavior of the hash table as an abstract data type. Silently throwing away the previously stored key-value pair in that location is equally unacceptable. We must find two locations to store these two different key-value pairs that map to the same hash, and we need to have a process for searching all the possible locations when our first array lookup fails (i.e., the lookup key doesn’t match the stored key).</p>
<p>There are a number of competing methods with different tradeoffs for solving what’s called <em>collision resolution</em> in hash tables. Two popular techniques are <em>separate chaining</em>, which uses extra storage outside the hash table array to hold the key-value pairs involved in collisions, and <em>open addressing</em>, which forces collisions into the currently unoccupied array locations (i.e., it uses no extra storage). Neither technique is superior over the other in all problem contexts. If you take an algorithms and data structures course, you’ll learn how to implement these schemes and learn the conditions under which one outperforms than the other.</p>
<p>To be clear, none of these techniques overcome the worst-case computational complexity of a hash table lookup. It is always possible, although unlikely with a good hash function, that all of your keys produce the same hash. In the worst-case behavior, a table lookup has <span class="math notranslate nohighlight">\(O(n)\)</span> work to do to find the key-value pair you desire, assuming you put <span class="math notranslate nohighlight">\(n\)</span> key-value pairs into the hash table before this lookup.</p>
</section>
<section id="specification-for-creating-a-book-index">
<p><strong>Specification for creating a book index.</strong> Enough about hash tables, their design, and their computational complexity, let’s use one to solve our book index problem! As I mentioned earlier, solving this problem will give us a flavor for what Google does to build its search index.</p>
<p>Our script will implement the following specification: <em>Given a simple text file and a special character sequence at the beginning of a line that indicates when we’re moving from one reference unit to the next, print a sorted list of word-references pairs.</em> Because there are many small words in human languages that are not something we typically include in a book index, our implementation will also ignore any words in the text that are shorter than some character bound.</p>
</section>
<section id="building-top-down">
<p><strong>Building top-down.</strong> Let’s begin our design by deciding that we’ll build the book index by processing our book a single line at a time, which is what we did to read a book in Chapter 1. It’s often good to start with a script structure around which we have some experience. We can always change our mind and adjust the design once we gain further insights into the work we have to do.</p>
<p>Let’s also decide that we’ll use a Python dictionary to store the word-reference pairs as we process each line in the input text. Recall that a Python dictionary is an implementation of the hash table abstract data type. But what exactly is a word-references pair?</p>
<p>Starting with the first part of this pair, we all intuitively know what a word is in a line of text, but what code do we have to write to extract words from our text file? Unfortunately, this is not an easy question to answer as some characters, like an apostrophe, are not only punctuation marks (i.e., single quotes) but also parts of a word (e.g., in the contraction “isn’t”).</p>
<aside class="margin sidebar">
<p class="sidebar-title">Looking Ahead</p>
<p>The cryptic code in <code class="docutils literal notranslate"><span class="pre">get_wordlist</span></code> uses regular expressions and lookahead, which we’ll cover in Chapter 13.</p>
</aside>
<p>We’ll “solve” this challenge by using a piece of code that we don’t yet understand to create a word list from a line of text. We’ll call this function <code class="docutils literal notranslate"><span class="pre">get_wordlist</span></code>, and it will take a line of text and return a Python list, where each element in the list is a word.</p>
<aside class="margin sidebar">
<p class="sidebar-title">Book Units</p>
<p>Recall that our specification requires the user to specify how we’ll recognize that we’re moving from one book unit to the next and what number to use as the initialization of that count of units.</p>
</aside>
<p>What about this “references” thing in the other half of the word-references pair? Let’s agree that this is a Python list of the book’s unit numbers in which you can find one or more instances of the word in the word-references pair. If the books units we want referenced in the book index are page numbers, this list would contain the list of pages on which you can find one or more instances of the word. If the books units are chapter numbers, this list would contain the list of chapters in which you can find one or more instances of the word. And so forth.</p>
<p>Great! With these decisions made, we can start writing some pseudocode!</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1"># Set book-unit pattern and initialize book-unit counter</span>
<span class="linenos"> 2</span><span class="c1"># Read the input book as one long string</span>
<span class="linenos"> 3</span><span class="c1"># Create an empty Python dictionary as our book index</span>
<span class="linenos"> 4</span><span class="c1"># </span>
<span class="linenos"> 5</span><span class="c1"># foreach line in the book:</span>
<span class="linenos"> 6</span><span class="c1">#     if line starts with book-unit pattern:</span>
<span class="linenos"> 7</span><span class="c1">#         increment book-unit counter</span>
<span class="linenos"> 8</span><span class="c1">#     create wordlist from line</span>
<span class="linenos"> 9</span><span class="c1">#     update book index given current book index, wordlist, book-unit counter</span>
<span class="linenos">10</span><span class="c1"># </span>
<span class="linenos">11</span><span class="c1"># print out book index</span>
</pre></div>
</div>
<p>Our pseudocode begins with a few initializations, and then it processes the book a line at a time, adding to the Python dictionary the words in each line. Although we didn’t say it in the pseudocode, we add only words greater than the minimum word length. We’ll have to remember to do that in our update function.</p>
<p>There’s nothing in this pseudocode that we haven’t already learned how to do, and so let’s jump right to a script that implements much of what we just described.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">### chap10/index0.py</span>
<span class="linenos"> 2</span><span class="kn">import</span> <span class="nn">re</span>
<span class="linenos"> 3</span><span class="kn">import</span> <span class="nn">string</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="c1"># Configuration constants for our index generation</span>
<span class="linenos"> 6</span><span class="n">MIN_LEN</span> <span class="o">=</span> <span class="mi">4</span>           <span class="c1"># don&#39;t index any words shorter than 5 chars</span>
<span class="linenos"> 7</span><span class="n">UNIT_PAT</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>         <span class="c1"># for pages in CatInTheHat.txt</span>
<span class="linenos"> 8</span><span class="n">UNIT_CNT_INIT</span> <span class="o">=</span> <span class="mi">1</span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="c1"># The magic function that turns a line into a wordlist</span>
<span class="linenos">11</span><span class="k">def</span> <span class="nf">get_wordlist</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
<span class="linenos">12</span>    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
<span class="linenos">13</span>    <span class="k">return</span> <span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;^[</span><span class="si">{0}</span><span class="s1">]+|[</span><span class="si">{0}</span><span class="s1">]+$&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">punctuation</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
<span class="linenos">14</span>            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
<span class="linenos">15</span>
<span class="linenos">16</span><span class="c1"># An unfortunately difficult check because of empty lines as</span>
<span class="linenos">17</span><span class="c1"># a unit break in CatInTheHat.txt</span>
<span class="linenos">18</span><span class="k">def</span> <span class="nf">found_new_unit</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
<span class="linenos">19</span>    <span class="k">if</span> <span class="n">UNIT_PAT</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
<span class="linenos">20</span>        <span class="k">return</span> <span class="n">UNIT_PAT</span> <span class="o">==</span> <span class="n">line</span>
<span class="linenos">21</span>    <span class="k">else</span><span class="p">:</span>
<span class="linenos">22</span>        <span class="k">return</span> <span class="n">UNIT_PAT</span> <span class="o">==</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">UNIT_PAT</span><span class="p">)]</span>
<span class="linenos">23</span>
<span class="linenos">24</span><span class="k">def</span> <span class="nf">update_index</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">wordlist</span><span class="p">,</span> <span class="n">unitno</span><span class="p">):</span>
<span class="linenos">25</span>    <span class="c1"># Needs to be written</span>
<span class="linenos">26</span>    <span class="k">return</span> <span class="n">d</span>
<span class="linenos">27</span>    
<span class="linenos">28</span><span class="k">def</span> <span class="nf">build_index</span><span class="p">(</span><span class="n">txt</span><span class="p">):</span>
<span class="linenos">29</span>    <span class="c1"># Start with an empty dictionary</span>
<span class="linenos">30</span>    <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
<span class="linenos">31</span>
<span class="linenos">32</span>    <span class="c1"># Iterate through each line in book watching for book unit boundaries</span>
<span class="linenos">33</span>    <span class="n">unitno</span> <span class="o">=</span> <span class="n">UNIT_CNT_INIT</span>
<span class="linenos">34</span>    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">txt</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
<span class="linenos">35</span>        <span class="k">if</span> <span class="n">found_new_unit</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
<span class="linenos">36</span>            <span class="n">unitno</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="linenos">37</span>        <span class="n">d</span> <span class="o">=</span> <span class="n">update_index</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">get_wordlist</span><span class="p">(</span><span class="n">line</span><span class="p">),</span> <span class="n">unitno</span><span class="p">)</span>
<span class="linenos">38</span>
<span class="linenos">39</span>    <span class="c1"># Print out the index</span>
<span class="linenos">40</span>    <span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<p>This script pulls out the work we need to do to update the dictionary (i.e., <code class="docutils literal notranslate"><span class="pre">update_index</span></code>, which is called on each iteration of the loop in <code class="docutils literal notranslate"><span class="pre">build_index</span></code>), since we haven’t yet written that pseudocode. Right now, the function <code class="docutils literal notranslate"><span class="pre">update_index</span></code> simply returns the dictionary it was passed.</p>
<p>The only other piece of code worth highlighting is that which implements the function <code class="docutils literal notranslate"><span class="pre">found_new_unit</span></code>. In one of the two text files we’ll use to test our script, <code class="docutils literal notranslate"><span class="pre">CatInTheHat.txt</span></code> uses blank lines to indicate the end of a page. Python naturally does the right thing in comparing two strings of different lengths, even if you ask it for a “substring” that is larger in size than the actual string. The only exceptional case is when one of the two strings is the empty string (<code class="docutils literal notranslate"><span class="pre">''</span></code>). The function <code class="docutils literal notranslate"><span class="pre">found_new_unit</span></code> handles this special case as a special case.</p>
<div class="admonition-you-try-it admonition">
<p class="admonition-title">You Try It</p>
<p>Can you figure out value is produced by the equality test on line 22 in the previous code block when <code class="docutils literal notranslate"><span class="pre">UNIT_PAT</span></code> is the empty string and <code class="docutils literal notranslate"><span class="pre">line</span></code> is <code class="docutils literal notranslate"><span class="pre">'This</span> <span class="pre">is</span> <span class="pre">NOT</span> <span class="pre">a</span> <span class="pre">blank</span> <span class="pre">line'</span></code>? When you do, you’ll see why we need the test on line 19.</p>
</div>
</section>
<section id="updating-the-index">
<p><strong>Updating the index.</strong> What is missing from our script is the implementation of <code class="docutils literal notranslate"><span class="pre">update_index</span></code> and the proper printing of the index. Right now, we don’t put any words into the dictionary and our printing code simply prints the contents of the dictionary. Let’s fill in <code class="docutils literal notranslate"><span class="pre">update_index</span></code> first, because we can test the core aspects of our implementation even without a proper printing routine.</p>
<p>This routine wants to do something for each word in <code class="docutils literal notranslate"><span class="pre">wordlist</span></code>. Let’s consider what might happen for each word:</p>
<ul class="simple">
<li><p>The simple case is when we find that the word is not in the dictionary (i.e., not yet in the index). In this case, we need to add the word and the value associated with it (i.e., <code class="docutils literal notranslate"><span class="pre">unitno</span></code>) to the dictionary. We’ll store the <code class="docutils literal notranslate"><span class="pre">unitno</span></code> as the first element in a list because we might later find the hashed word in another unit of the book.</p></li>
<li><p>When the word is already in the dictionary, we still have work to do. We must check if the current unit number (e.g., the page or chapter number on which we now find this word) is already in the stored list of units. If it is, we have nothing to do (e.g., we don’t add the same page number twice). If it isn’t, we need to add the current unit number to the end of the references list.</p></li>
</ul>
<p>The following code implements this functionality using the methods of a Python dictionary.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">32</span><span class="c1">### chap10/index1.py</span>
<span class="linenos">33</span><span class="k">def</span> <span class="nf">update_index</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">wordlist</span><span class="p">,</span> <span class="n">unitno</span><span class="p">):</span>
<span class="linenos">34</span>    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">wordlist</span><span class="p">:</span>
<span class="linenos">35</span>        <span class="c1"># Update our dictionary</span>
<span class="linenos">36</span>        <span class="k">if</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
<span class="linenos">37</span>            <span class="k">if</span> <span class="n">unitno</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">word</span><span class="p">]:</span>
<span class="linenos">38</span>                <span class="n">d</span><span class="p">[</span><span class="n">word</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unitno</span><span class="p">)</span>
<span class="linenos">39</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">40</span>            <span class="n">d</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">unitno</span><span class="p">]</span>
<span class="linenos">41</span>
<span class="linenos">42</span>    <span class="k">return</span> <span class="n">d</span>
</pre></div>
</div>
<p>Let’s run some simple tests to see if this work and what we might have forgotten. We will use Python’s ability to easily create multiline strings using triple quotes.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="n">txt</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;&quot;Now! Now! Have no fear.</span>
<span class="linenos">2</span><span class="s1">Have no fear!&quot; said the cat.</span>
<span class="linenos">3</span><span class="s1">&quot;My tricks are not bad,&quot;</span>
<span class="linenos">4</span><span class="s1">Said the Cat in the Hat.&#39;&#39;&#39;</span>
<span class="linenos">5</span><span class="n">build_index</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
</pre></div>
</div>
<p>Oops. When you run this code block, the first thing you note is that we forgot to filter out words less than <code class="docutils literal notranslate"><span class="pre">MIN_LEN</span></code>. That’s an easy fix.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">32</span><span class="c1">### chap10/index2.py</span>
<span class="linenos">33</span><span class="k">def</span> <span class="nf">update_index</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">wordlist</span><span class="p">,</span> <span class="n">unitno</span><span class="p">):</span>
<span class="linenos">34</span>    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">wordlist</span><span class="p">:</span>
<span class="linenos">35</span>        <span class="c1"># Skip short words</span>
<span class="linenos">36</span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">MIN_LEN</span><span class="p">:</span>
<span class="linenos">37</span>            <span class="k">continue</span>
<span class="linenos">38</span>        
<span class="linenos">39</span>        <span class="c1"># Update our dictionary</span>
<span class="linenos">40</span>        <span class="k">if</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
<span class="linenos">41</span>            <span class="k">if</span> <span class="n">unitno</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">word</span><span class="p">]:</span>
<span class="linenos">42</span>                <span class="n">d</span><span class="p">[</span><span class="n">word</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unitno</span><span class="p">)</span>
<span class="linenos">43</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">44</span>            <span class="n">d</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">unitno</span><span class="p">]</span>
<span class="linenos">45</span>
<span class="linenos">46</span>    <span class="k">return</span> <span class="n">d</span>
</pre></div>
</div>
<p>Let’s try again.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="n">txt</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;&quot;Now! Now! Have no fear.</span>
<span class="linenos">2</span><span class="s1">Have no fear!&quot; said the cat.</span>
<span class="linenos">3</span><span class="s1">&quot;My tricks are not bad,&quot;</span>
<span class="linenos">4</span><span class="s1">Said the Cat in the Hat.&#39;&#39;&#39;</span>
<span class="linenos">5</span><span class="n">build_index</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
</pre></div>
</div>
<p>This looks much better, except … do we really want both <code class="docutils literal notranslate"><span class="pre">'said'</span></code> and <code class="docutils literal notranslate"><span class="pre">'Said'</span></code> separately in our dictionary? Probably not. We will use the <code class="docutils literal notranslate"><span class="pre">lower</span></code> method on strings to make sure it doesn’t matter how a word was capitalized.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">32</span><span class="c1">### chap10/index3.py</span>
<span class="linenos">33</span><span class="k">def</span> <span class="nf">update_index</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">wordlist</span><span class="p">,</span> <span class="n">unitno</span><span class="p">):</span>
<span class="linenos">34</span>    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">wordlist</span><span class="p">:</span>
<span class="linenos">35</span>        <span class="c1"># Skip short words</span>
<span class="linenos">36</span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">MIN_LEN</span><span class="p">:</span>
<span class="linenos">37</span>            <span class="k">continue</span>
<span class="linenos">38</span>        
<span class="linenos">39</span>        <span class="c1"># No capitals</span>
<span class="linenos">40</span>        <span class="n">word</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
<span class="linenos">41</span>
<span class="linenos">42</span>        <span class="c1"># Update our dictionary</span>
<span class="linenos">43</span>        <span class="k">if</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
<span class="linenos">44</span>            <span class="k">if</span> <span class="n">unitno</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">word</span><span class="p">]:</span>
<span class="linenos">45</span>                <span class="n">d</span><span class="p">[</span><span class="n">word</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unitno</span><span class="p">)</span>
<span class="linenos">46</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">47</span>            <span class="n">d</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">unitno</span><span class="p">]</span>
<span class="linenos">48</span>
<span class="linenos">49</span>    <span class="k">return</span> <span class="n">d</span>
</pre></div>
</div>
<p>This time we will test with “multiple pages” in our input.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="n">txt</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;&quot;Now! Now! Have no fear.</span>
<span class="linenos"> 2</span><span class="s1">Have no fear!&quot; said the cat.</span>
<span class="linenos"> 3</span><span class="s1">&quot;My tricks are not bad,&quot;</span>
<span class="linenos"> 4</span><span class="s1">Said the Cat in the Hat.</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="s1">&quot;Why, we can have</span>
<span class="linenos"> 7</span><span class="s1">Lots of good fun, if you wish,</span>
<span class="linenos"> 8</span><span class="s1">With a game that I call</span>
<span class="linenos"> 9</span><span class="s1">UP-UP-UP with a fish!&quot;</span>
<span class="linenos">10</span>
<span class="linenos">11</span><span class="s1">&quot;Put me down!&quot; said the fish.</span>
<span class="linenos">12</span><span class="s1">&quot;This is no fun at all!</span>
<span class="linenos">13</span><span class="s1">Put me down!&quot; said the fish.</span>
<span class="linenos">14</span><span class="s1">&quot;I do NOT wish to fall!&quot;&#39;&#39;&#39;</span>
<span class="linenos">15</span>
<span class="linenos">16</span><span class="n">build_index</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
</pre></div>
</div>
<p>This looks quite good, but notice that you cannot predict the order of the keys in a Python dictionary. When we called <code class="docutils literal notranslate"><span class="pre">update_index</span></code> only once (e.g., in our first test above), it looked like the words were stored in the dictionary in the order we inserted them, but in our last test, after several calls to <code class="docutils literal notranslate"><span class="pre">update_index</span></code>, this was no longer true.</p>
</section>
<section id="sort-and-strip">
<p><strong>Sort and strip.</strong> Ok, but we have to print the index so that it looks like a book index. This isn’t that hard, since Python dictionaries allow you to iterate through the keys in a dictionary and even use Python’s built-in <code class="docutils literal notranslate"><span class="pre">sorted</span></code> function to sort the keys in the key iterator.</p>
<p>The only other thing we’ll want to do is strip the square brackets off the list of references when we convert this list to a string. Here’s the final version of <code class="docutils literal notranslate"><span class="pre">build_index</span></code> and a rerun of the last test.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">50</span><span class="c1">### chap10/index32.py</span>
<span class="linenos">51</span><span class="k">def</span> <span class="nf">build_index</span><span class="p">(</span><span class="n">txt</span><span class="p">):</span>
<span class="linenos">52</span>    <span class="c1"># Start with an empty dictionary</span>
<span class="linenos">53</span>    <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
<span class="linenos">54</span>
<span class="linenos">55</span>    <span class="c1"># Iterate through each line in book watching for book unit boundaries</span>
<span class="linenos">56</span>    <span class="n">unitno</span> <span class="o">=</span> <span class="n">UNIT_CNT_INIT</span>
<span class="linenos">57</span>    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">txt</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
<span class="linenos">58</span>        <span class="k">if</span> <span class="n">found_new_unit</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
<span class="linenos">59</span>            <span class="n">unitno</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="linenos">60</span>        <span class="n">d</span> <span class="o">=</span> <span class="n">update_index</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">get_wordlist</span><span class="p">(</span><span class="n">line</span><span class="p">),</span> <span class="n">unitno</span><span class="p">)</span>
<span class="linenos">61</span>
<span class="linenos">62</span>    <span class="c1"># Print out the index</span>
<span class="linenos">63</span>    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="linenos">64</span>        <span class="n">pages</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">w</span><span class="p">])</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;[]&#39;</span><span class="p">)</span>
<span class="linenos">65</span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">w</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">pages</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="c1"># Using the last value of `txt`</span>
<span class="linenos">2</span><span class="n">build_index</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
</pre></div>
</div>
<p>You now have a general idea how Google takes a search string we give it and quickly provides us with a list of pages containing the keywords in our search. It simply looks up the search string’s keywords in a big hash table, and each lookup takes constant time. None of this work takes time proportional to the size of all the pages in the indexed web, and we quickly get an answer!</p>
<p>Of course, Google does more than just this, as we’ll discuss in the following chapters, but this is a great start. Congratulations!</p>
<p>[Version 20230817]</p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="chap09.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Chapter 9: Find a Phrase</p>
      </div>
    </a>
    <a class="right-next"
       href="chap11.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Chapter 11: Discover Driving Directions</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#strings-to-numbers">Strings to numbers</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-simple-hash-function">A simple hash function</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#updating-a-hash-with-o-1-work">Updating a hash with O(1) work</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#allow-collisions">Allow collisions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#other-applications-of-hashing">Other applications of hashing</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#indices-for-fast-data-retrieval">Indices for fast data retrieval</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#hash-tables">Hash tables</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-speed-of-array-index-operations">The speed of array-index operations</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#with-high-probability">With high probability</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#collision-resolution">Collision resolution</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#specification-for-creating-a-book-index">Specification for creating a book index</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#building-top-down">Building top-down</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#updating-the-index">Updating the index</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#sort-and-strip">Sort and strip</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Mike Smith
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2023 by Michael D. Smith. All rights reserved.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>