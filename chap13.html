

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Chapter 13: Rewrite the Error Message &#8212; Computational Thinking and Problem Solving</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/myfile.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'chap13';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Chapter 14: The Dream of Bug Fixing" href="chap14.html" />
    <link rel="prev" title="Chapter 12: Divide and Conquer" href="chap12.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="ctps.html">
  
  
  
  
    
    
      
    
    
    <img src="_static/mike_flat.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="_static/mike_flat.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="ctps.html">
                    <no title>
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="welcome.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap01.html">Chapter 1: Read a Children’s Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap02.html">Chapter 2: Grab the Dialogue</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap03.html">Chapter 3: Replace Text With Emoji</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap04.html">Chapter 4: Query a Web Resource</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap05.html">Chapter 5: Play Guess-a-number</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap06.html">Chapter 6: Do You See My Dog?</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap07.html">Chapter 7: Many But Not Any Number</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap08.html">Chapter 8: What Is My Problem?</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap09.html">Chapter 9: Find a Phrase</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap10.html">Chapter 10: Build an Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap11.html">Chapter 11: Discover Driving Directions</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap12.html">Chapter 12: Divide and Conquer</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Chapter 13: Rewrite the Error Message</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap14.html">Chapter 14: The Dream of Bug Fixing</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap15.html">Chapter 15: Embrace Runtime Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap16.html">Chapter 16: Catch Them Early</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap17.html">Chapter 17: Build Prediction Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap18.html">Chapter 18: Use Generative AI</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="ales.html">Active-Learning Exercises</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="ales-c01.html">Chapter 1</a></li>
<li class="toctree-l2"><a class="reference internal" href="ales-c02.html">Chapter 2</a></li>







<li class="toctree-l2"><a class="reference internal" href="ales-c03.html">Chapter 3</a></li>








<li class="toctree-l2"><a class="reference internal" href="ales-c04.html">Chapter 4</a></li>





<li class="toctree-l2"><a class="reference internal" href="ales-c05.html">Chapter 5</a></li>
<li class="toctree-l2"><a class="reference internal" href="ales-c06.html">Chapter 6</a></li>
<li class="toctree-l2"><a class="reference internal" href="ales-c07.html">Chapter 7</a></li>
<li class="toctree-l2"><a class="reference internal" href="ales-c08.html">Chapter 8</a></li>
<li class="toctree-l2"><a class="reference internal" href="ales-c09.html">Chapter 9</a></li>



<li class="toctree-l2"><a class="reference internal" href="ales-c10.html">Chapter 10</a></li>


<li class="toctree-l2"><a class="reference internal" href="ales-c12.html">Chapter 12</a></li>



</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/chap13.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Chapter 13: Rewrite the Error Message</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-mistakes-we-make-in-problem-solving">The mistakes we make in problem solving</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#our-problem-to-be-solved">Our problem-to-be-solved</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#from-the-gui-to-the-shell">From the GUI to the shell</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#understanding-paths">Understanding paths</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#from-paths-to-programs">From paths to programs</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#redirecting-inputs-and-outputs">Redirecting inputs and outputs</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#which-output">Which output?</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pattern-matching">Pattern matching</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#wildcards-in-the-shell">Wildcards in the shell</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#regular-expressions">Regular expressions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#finding-simple-words">Finding simple words</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#matching-metacharacters">Matching metacharacters</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#using-res">Using REs</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#finding-filenames">Finding filenames</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-promise-fulfilled">A promise fulfilled</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#python-re-extensions">Python RE extensions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#putting-it-all-together">Putting it all together</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#shell-pipes">Shell pipes</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#scripting-what-the-shell-did">Scripting what the shell did</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#concurrency">Concurrency</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#making-python32-look-like-python3">Making python32 look like python3</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="chapter-13-rewrite-the-error-message">
<h1>Chapter 13: Rewrite the Error Message<a class="headerlink" href="#chapter-13-rewrite-the-error-message" title="Permalink to this heading">#</a></h1>
<p>The last act began with the recognition that our world is wondrously complex, and we ended it with the realization that this complexity is sometimes disturbingly simple to overcome with the right tool. For example, a divide-and-conquer approach was exactly what we needed in Chapter 12 to tackle Beckett’s Challenge and recursion was the right technique for coding a short solution. Finding the right computational tool for your task is the theme of this final act. With the right tool, solving your problems becomes straightforward.</p>
<p>Well, almost. Even if you pick the right tool, you still need to get it to do what you want. In the previous two acts, you became proficient at problem solving by writing scripts, and that’s half the battle when using computational tools. The other half is knowing what to do when your script fails to direct a tool in the way you’d like. My goal for you in this act is to have you become more skilled at understanding how your script can fail and more proficient at fixing these failures. And the best way I’ve learned to achieve this is to collect together the types of mistakes we make in our scripts and then categorize how these mistakes manifest themselves in our computational tools. In a moment, I’ll present such a categorization, and then we’ll explore its implications in this and the next few chapters.</p>
<p>Beyond our own human propensity for errors, we also need to understand the limitations of our tools. Just like you, computational tools are good at some things and not so good at others. You can often force a computational tool to do an unnatural task (e.g., use a for- or while-loop to solve a problem that’s more elegantly solved with recursion), but the work required and the errors that arise are often daunting. Sometimes it is not even possible to force a tool to do what you want, as we’ll see in the next chapter.</p>
<p>The key to picking the right tool surfaces the last of our fundamental ideas in computer science: <em>pattern matching</em>. When we can identify the patterns in our problems and match them with the patterns our tools exploit, hard problems become magically easy to solve. We’ll start in this chapter looking at a tool to recognize and exploit the patterns in strings, and we’ll play with some of the most powerful of these tools for other types of real-world data in the act’s last two chapters.</p>
<p>I wish that the challenges ended here, but they don’t. Even when a tool works, we must consider the social implications of a computational solution. Here we ask, will our use of a tool unfairly harm some individuals or the fabric of society? Computational solutions that don’t consider this critical question are all too common in our modern world, and we’ll dive into these social issues in the act’s last two chapters.</p>
<section id="the-mistakes-we-make-in-problem-solving">
<p><strong>The mistakes we make in problem solving.</strong> It’s been quite some time since we looked at the list of steps in our problem solving process. Let’s return to that list, but reframe the last three steps to reflect the knowledge we’ve gained over the past two acts.</p>
<p>Recall that the process begins with us precisely specifying our problem (step 1) and imagining a few specific instances of it (step 2). We next decompose it into its different tasks (step 3), decide which tasks are computational in nature (step 4), and identify existing algorithms, libraries, and our own previously written code that might help (step 5). This brings us to the last three steps, which we previously described as sketch, translate, and execute. We now know that these steps require us to:</p>
<ol class="arabic simple">
<li><p>Determine a reasonable abstraction level at which to solve each task;</p></li>
<li><p>Build a digital representation of each task and its associated data structures;</p></li>
<li><p>Design or identify algorithms that work over these representations and data structures, which together allow us to solve the individual tasks and ultimately the overall problem;</p></li>
<li><p>Code these algorithms and data structures in a programming language like Python, taking advantage of its built-in functionality and the rich set of public libraries and modules from its user community.</p></li>
</ol>
<p>We also learned that we need to revisit earlier steps when our scripts fail, but we never tried to categorize these failures. Let’s do that now. Our goal will be to gain an understanding that allows us to proficiently handle each category and possibly even avoid a category of errors all together.</p>
<p>There are basically four types of errors we make, which are classified based on the ways that a script fails to execute or fails to execute according to a specification:</p>
<ol class="arabic simple">
<li><p>We sometimes write statements that <strong>aren’t legal Python</strong>. These are <em>syntax errors</em> that stop the interpreter dead in its tracks. “What did you say?” it will ask. “I don’t understand you.”</p></li>
<li><p>We sometimes write statements that <strong>are legal Python</strong>, but what these statements ask the interpreter to do with the data we give it <strong>isn’t something it can do</strong> (e.g., convert the word <code class="docutils literal notranslate"><span class="pre">&quot;junk&quot;</span></code> into an integer). These are <em>runtime errors</em> that stop the interpreter, again, dead in its tracks. “I can’t do that,” it’ll say, occasionally in really-hard-to-understand error messages.</p></li>
<li><p>We sometimes write statements that <strong>are legal Python and something the interpreter can do</strong>, but <strong>the result it produces makes no sense</strong>. These are <em>design errors</em> (i.e., solving your problem incorrectly) and <em>subtle coding errors</em> (e.g., writing a script with an infinite loop or multiplying a value by the wrong constant) that are quite hard to diagnose and correct. We’ll have to find ways to verify which parts of the script (including its data structures) are operating correctly and which incorrectly.</p></li>
<li><p>We sometimes write a script that <strong>produces a sensible answer</strong>, but it <strong>takes too long</strong> to run to completion (e.g., our script uses a brute-force approach on a problem with a very large input) or in some other way <strong>misses an important problem constraint</strong> (e.g., our script uses too much memory). These are <em>missed constraints</em>. They often require us to be smarter in our problem-solving approach, typically in the selection of an algorithm, as we discussed in the last act.</p></li>
</ol>
</section>
<section id="our-problem-to-be-solved">
<p><strong>Our problem-to-be-solved.</strong> In this chapter, you are going to become more adept at fixing the syntax and runtime errors in your scripts. To do this, you need to understand and quickly process the Python interpreter’s error messages. Let’s assume we understand the information in the interpreter’s error messages so that our focus is on quickly processing these messages. Now let me ask, “Have you found it easy to read these messages?” Here’s a typical one, which I get when I run the Python interpreter on a script with a straightforward runtime error. In reading the script’s output, the first two lines are lists that I asked the script to print; the error message starts with the “Traceback” line.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>### Run the highlighted command in the shell
<span class="hll">chap13$ python3 broken.py
</span>[&#39;this&#39;, &#39;is&#39;, &#39;a&#39;, &#39;test&#39;]
[&#39;his&#39;, &#39;is&#39;, &#39;another&#39;, &#39;test&#39;]
Traceback (most recent call last):
  File &quot;/home/runner/chap13/broken.py&quot;, line 23, in &lt;module&gt;
    main()
  File &quot;/home/runner/chap13/broken.py&quot;, line 20, in main
    f_undef_name()
  File &quot;/home/runner/chap13/broken.py&quot;, line 5, in f_undef_name
    print(undef_name)
NameError: name &#39;undef_name&#39; is not defined. Did you mean: &#39;f_undef_name&#39;?
</pre></div>
</div>
<div class="admonition-you-try-it admonition">
<p class="admonition-title">You Try It</p>
<p>The script <code class="docutils literal notranslate"><span class="pre">broken.py</span></code> is in the <code class="docutils literal notranslate"><span class="pre">chap13</span></code> files in this book’s code repository. We’ll talk in a moment how you interpret <code class="docutils literal notranslate"><span class="pre">&quot;/home/runner/chap13/broken.py&quot;</span></code>; you might see a different substring before <code class="docutils literal notranslate"><span class="pre">broken.py</span></code>. Make sure that you run the highlighted command for yourself. There are a lot of shell commands to try throughout this chapter.</p>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">NameError</span></code> is a mistake we learned about in Chapter 1. It occurs when we ask the interpreter to grab a value from a name that wasn’t previously defined. In this particular message, the interpreter tries to help us correct our mistake by suggesting a defined name that is close to what we typed. We’ll need to look at the line in <code class="docutils literal notranslate"><span class="pre">broken.py</span></code> to see if its suggestion is the fix we need. Quick, what line contains the error?</p>
<div class="admonition-you-try-it admonition">
<p class="admonition-title">You Try It</p>
<p>To answer the question of what line contains the error, look at the previous code block.<a class="footnote-reference brackets" href="#fn1" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p>
</div>
<p>I’ve been coding in Python for quite some time, and I still forget if it is the first or the last of the traceback items. Imagine if we could run the Python interpreter and have it format its error messages in a manner we find easy to read. Perhaps something like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>### A better formatted error message
<span class="hll">chap13$ ./python32 broken.py
</span>[&#39;this&#39;, &#39;is&#39;, &#39;a&#39;, &#39;test&#39;]
[&#39;his&#39;, &#39;is&#39;, &#39;another&#39;, &#39;test&#39;]

**Hit an ERROR** in broken.py on line 5
inside function f_undef_name:

4: def f_undef_name():
5:     print(undef_name)
6: 

NameError: name &#39;undef_name&#39; is not defined. Did you mean: &#39;f_undef_name&#39;?

**Call stack at ERROR**
Function f_undef_name was called from
  ↜ main in broken.py on line 20, which was called from
   ↜ &lt;module&gt; in broken.py on line 23
</pre></div>
</div>
<p>This output contains all the same information as the original error message, but I’ve rearranged it so that I’m first presented with where the error occurred. The call stack comes last because I want to know the error first before I try to understand the context that brought me to this execution point. This output also shortens the filenames, and as a final flourish, it uses color to highlight the important information. This may not be exactly what you’d prefer, but I hope you see that a reorganization of the information could be extremely helpful.</p>
<p>Changing the Python interpreter’s error message in this way will be our problem-to-be-solved, and we can enumerate the tasks involved:</p>
<ol class="arabic simple">
<li><p>Send the script to run along with all its input parameters to the Python interpreter.</p></li>
<li><p>Capture the interpreter’s error output, if any, before it is displayed.</p></li>
<li><p>Recognize the patterns in this output and rewrite the error message.</p></li>
<li><p>Output this rewritten message as if the interpreter had written it.</p></li>
</ol>
<p>Notice that we want only to insert ourselves where we want different work to occur.<a class="footnote-reference brackets" href="#fn2" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> We don’t want to figure out how to do all the work that the Python interpreter does to run the script and identify its errors. And as much as possible, we’d like to make it match what we do when running the Python interpreter. Did you notice that the command I ran in the last code block wasn’t the Python interpreter? If you didn’t, that’s good. You’ll learn exactly how the command I used works and how to build it by the end of this chapter.</p>
<div class="admonition-learning-outcomes admonition">
<p class="admonition-title">Learning Outcomes</p>
<p>Learn how pattern matching can be the right tool for your problem. Working with regular expressions, a language to match patterns in strings, you’ll write a script to capture the essence of the Python interpreter’s error messages and rewrite them. To have it look like the interpreter outputs your rewritten message, you’ll learn about the shell, common shell commands, and ways to write a Python script that automates your interactions with the shell. In particular, after completing this chapter, you will be able to:</p>
<ul class="simple">
<li><p>Understand the categories of mistakes we make in problem solving: syntax errors, runtime errors, design errors, and missed constraints [design and CS concepts];</p></li>
<li><p>Describe the difference between a graphical user interface (GUI) and a command line interface (CLI) [CS concepts];</p></li>
<li><p>Discuss Unix-like filesystem paths, their components, and how they help you move around in the filesystem [CS concepts];</p></li>
<li><p>Understand how the shell finds the programs corresponding to the commands you type and how you can turn your scripts into commands that the shell will run [CS concepts and programming skills];</p></li>
<li><p>Use redirection and pipes to change where a program gets its inputs and sends its outputs, including it error outputs [CS concepts and programming skills];</p></li>
<li><p>Use some simple wildcard expressions in your shell commands [programming skills];</p></li>
<li><p>Employ some of the most commonly useful shell commands [programming skills];</p></li>
<li><p>Describe the difference between data and executable files, and how the shell tells the difference [CS concepts];</p></li>
<li><p>Work with regular expressions and Python’s <code class="docutils literal notranslate"><span class="pre">re</span></code> library [CS concepts and programming skills];</p></li>
<li><p>Write a script that launches programs as subprocesses and defines the communication channels between them [CS concepts and programming skills].</p></li>
</ul>
</div>
</section>
<section id="from-the-gui-to-the-shell">
<p><strong>From the GUI to the shell.</strong> As is typical, we’ll solve our problem in parts. We’ll begin with our first task, and to understand how to solve it, we’ll need to learn more about the shell and how you can command it to do things. We’ve mostly used the shell to run the Python interpreter on our scripts, and infrequently we issued it some commands to organize our files and directories (i.e., folders). But the shell is much more powerful. It can do all sorts of things for us.</p>
<p>When you want to do something on your computer, like move a file from one folder to another, you probably did it using the computer’s <em>graphical user interface (GUI)</em>. You’d click on a file and drag it from one folder to another. Like the GUI, the shell also allows you to perform such operations, but you direct it with text commands, not mouse clicks.<a class="footnote-reference brackets" href="#fn3" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p>
<p>As another example, if I wanted to see a list of the files and directories in a folder called <code class="docutils literal notranslate"><span class="pre">chap13</span></code>, I can use either of these interfaces:</p>
<ul class="simple">
<li><p>GUI: Put the cursor over the folder and double click it.</p></li>
<li><p>shell: Type <code class="docutils literal notranslate"><span class="pre">ls</span> <span class="pre">chap13</span></code> at the shell prompt.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">ls</span></code> stands for “list directory contents” and it is a program that someone wrote. You can learn what it does by typing <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">ls</span></code> at the shell prompt or in a browser search bar. <code class="docutils literal notranslate"><span class="pre">man</span></code> stands for “format and display the on-line manual pages.”<a class="footnote-reference brackets" href="#fn4" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a></p>
<div class="admonition-you-try-it admonition">
<p class="admonition-title">You Try It</p>
<p>Don’t just read about these programs and shell commands. Bring up a terminal window on your machine, and try the commands for yourself.</p>
</div>
</section>
<section id="understanding-paths">
<p><strong>Understanding paths.</strong> In the GUI, you can only double-click a folder if the folder in which it sits is open. To navigate to the folder containing the folder <code class="docutils literal notranslate"><span class="pre">chap13</span></code> in the shell, we use the <code class="docutils literal notranslate"><span class="pre">cd</span></code> command. <code class="docutils literal notranslate"><span class="pre">cd</span></code> stands for “change the shell working directory” or “change directory” for short.</p>
<p>You can see the name (technically <em>path</em>) for your working directory by typing <code class="docutils literal notranslate"><span class="pre">pwd</span></code>, which stands for “return working directory name” or “print working directory” in colloquial terms. Your working directory in a GUI is the one that you have open and active.</p>
<p>When I ran <code class="docutils literal notranslate"><span class="pre">python3</span> <span class="pre">broken.py</span></code> in the earlier code block, I was in the working directory <code class="docutils literal notranslate"><span class="pre">/home/runner/chap13</span></code> on Replit, and this is what computer scientists call an <em>absolute path</em>.<a class="footnote-reference brackets" href="#fn5" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> Such paths start at the <em>root of the file system</em>, which is represented by a single slash (<code class="docutils literal notranslate"><span class="pre">/</span></code>) with nothing before it. In Replit’s filesystem, <code class="docutils literal notranslate"><span class="pre">home</span></code> is the name of a folder in the root directory, and <code class="docutils literal notranslate"><span class="pre">runner</span></code> is a folder inside <code class="docutils literal notranslate"><span class="pre">home</span></code>. Finally, <code class="docutils literal notranslate"><span class="pre">chap13</span></code> is a folder inside <code class="docutils literal notranslate"><span class="pre">runner</span></code>.</p>
<p>Because there are absolute paths, we must also be able to specify <em>relative paths</em>. Using a relative path tells the shell that we want the path interpreted from our working directory, not the filesystem root. For example, if our working directory is <code class="docutils literal notranslate"><span class="pre">/home/runner</span></code> and within the folder <code class="docutils literal notranslate"><span class="pre">chap13</span></code> is the folder <code class="docutils literal notranslate"><span class="pre">data</span></code>, then we could type <code class="docutils literal notranslate"><span class="pre">ls</span> <span class="pre">chap13/data</span></code> to list the contents of the <code class="docutils literal notranslate"><span class="pre">data</span></code> folder. The string <code class="docutils literal notranslate"><span class="pre">chap13/data</span></code> is an example of a relative path that specifies where I want <code class="docutils literal notranslate"><span class="pre">ls</span></code> to do its work.</p>
<p>So far I’ve talked about how to go deeper into folders with a relative path, but we may also want to navigate to the parent or grandparent folders of our working directory. We could, of course, specify a folder’s <em>parent directory</em> (i.e., the folder containing our working directory) by typing out its absolute path from the root, but that might be a lot to type. So we have a way to say that in a relative fashion: two period characters together (<code class="docutils literal notranslate"><span class="pre">..</span></code>) in a path means that we want the parent of the current working directory. The following are a few example commands that use this way of specifying a parent directory:</p>
<ul class="simple">
<li><p>To list the contents of the parent of the working directory, type:</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">ls</span> <span class="pre">..</span></code></p>
<ul class="simple">
<li><p>To change your working directory to the parent of the working directory, type:</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">cd</span> <span class="pre">..</span></code></p>
<ul class="simple">
<li><p>To change to the grandparent, type:</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">cd</span> <span class="pre">../..</span></code></p>
<p>A single period (<code class="docutils literal notranslate"><span class="pre">.</span></code>) in a relative path is another shorthand; it’s another name for the working directory. It allows us to emphasize that we’d like the shell to interpret the path we give it from the working directory. If our working directory is <code class="docutils literal notranslate"><span class="pre">/home/runner</span></code>, the following are two equivalent ways of specifying a relative path to <code class="docutils literal notranslate"><span class="pre">data</span></code>:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">./chap13/data</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">chap13/data</span></code></p></li>
</ol>
<p>You might be wondering when using this shorthand is useful because the example shows that I have to type more to do the same thing. I’m glad you asked!</p>
</section>
<section id="from-paths-to-programs">
<p><strong>From paths to programs.</strong> When we want to run a program in a GUI, we double-click its icon. When we want to run a program in the shell, we type its name at the shell prompt followed by its input parameters, as we did earlier to invoke the Python interpreter on a particular script: <code class="docutils literal notranslate"><span class="pre">python3</span> <span class="pre">broken.py</span></code>. But what did it mean when I typed this at the shell prompt: <code class="docutils literal notranslate"><span class="pre">./python32</span> <span class="pre">test.py</span></code>?</p>
<p>We just learned that a path that starts with <code class="docutils literal notranslate"><span class="pre">./</span></code> means we want the shell to look in the working directory for the name that follows. So <code class="docutils literal notranslate"><span class="pre">./python32</span></code> tells the shell that our command is called <code class="docutils literal notranslate"><span class="pre">python32</span></code> and it’s located in the working directory. Ok, but typing just <code class="docutils literal notranslate"><span class="pre">python32</span></code> would have been fine too, right?</p>
<p>Wrong. Commands are <em>executable files</em>. They command our computer to do things, and we need to be careful how we command our computers. For example, we don’t want to mistakenly command it to delete all our files. Even if <code class="docutils literal notranslate"><span class="pre">python32</span></code> is in my working directory, typing <code class="docutils literal notranslate"><span class="pre">python32</span></code> at the shell prompt won’t start its execution. If you try, the shell should reply with “command not found.”</p>
<p>But wait, you say. The command <code class="docutils literal notranslate"><span class="pre">ls</span></code> wasn’t in our working directory when we asked the shell to run it. Where does the shell look to find commands?</p>
<p>The answer is <em>shell variables</em>. As I hinted earlier, our shell is programmable. It has the concept of: (1) variables that can take on different values; and (2) built-in commands, like Python’s built-in functions, that just work.<a class="footnote-reference brackets" href="#fn6" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a> Here is one of those built-in commands:</p>
<p><code class="docutils literal notranslate"><span class="pre">echo</span> <span class="pre">$PATH</span></code></p>
<p>This built-in command displays the value of the specified shell variable, and if you run this command, you’ll see that the <code class="docutils literal notranslate"><span class="pre">$PATH</span></code> shell variable contains an ordered, colon-separated list of directories.<a class="footnote-reference brackets" href="#fn7" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a> This list is where the shell will search looking for (non-built-in) commands. The executable file <code class="docutils literal notranslate"><span class="pre">ls</span></code> is in one of these directories and <code class="docutils literal notranslate"><span class="pre">python32</span></code> is not. That’s why typing <code class="docutils literal notranslate"><span class="pre">ls</span></code> at the shell prompt worked and typing <code class="docutils literal notranslate"><span class="pre">python32</span></code> didn’t.</p>
<p>On the other hand, I might want to run a program that isn’t in the <code class="docutils literal notranslate"><span class="pre">$PATH</span></code> list. I can run such programs by specifying it using its absolute path or an explicitly relative one. When I do this, the shell will look for that command only at that path. This is why <code class="docutils literal notranslate"><span class="pre">./python32</span></code> works despite the fact that this executable file is not in the <code class="docutils literal notranslate"><span class="pre">$PATH</span></code> list.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>When you type <code class="docutils literal notranslate"><span class="pre">echo</span> <span class="pre">$PATH</span></code> at your shell prompt and hit return, you’ll notice that the current working directory is not in <code class="docutils literal notranslate"><span class="pre">$PATH</span></code>. This is a security best practice. You should never add <code class="docutils literal notranslate"><span class="pre">.</span></code> to the list of directories in this shell variable. Only trusted directories should be in it.</p>
</div>
<p>So <code class="docutils literal notranslate"><span class="pre">./python32</span></code> is how we tell the shell that we want to run the program <code class="docutils literal notranslate"><span class="pre">python32</span></code> that we built and saved in our working directory. Later in this chapter we’ll see that <code class="docutils literal notranslate"><span class="pre">python32</span></code> is a Python script that begins by invoking the Python interpreter on this script’s input parameters. But before we look at that code in detail, let’s learn how to accomplish Tasks 2 and 3.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>I’ve written as if all operating system shells use the same commands and syntax, but they don’t. What I’ve shown you is true for most Unix-based systems, which is what you get on Replit and in Google Colab. But even on a Unix-based system, there are many different shells that act similarly but not identically. Typically, you can learn which shell you’re using by typing <code class="docutils literal notranslate"><span class="pre">echo</span> <span class="pre">$SHELL</span></code> and then ask <code class="docutils literal notranslate"><span class="pre">man</span></code> about it. I’ve also described only a small handful of the programs and shell commands you’ll find useful in problem solving. To continue building your shell skills, use <code class="docutils literal notranslate"><span class="pre">man</span></code> to learn about <code class="docutils literal notranslate"><span class="pre">cp</span></code>, <code class="docutils literal notranslate"><span class="pre">mv</span></code>, <code class="docutils literal notranslate"><span class="pre">rm</span></code>, <code class="docutils literal notranslate"><span class="pre">mkdir</span></code>, <code class="docutils literal notranslate"><span class="pre">rmdir</span></code>, <code class="docutils literal notranslate"><span class="pre">cat</span></code>, <code class="docutils literal notranslate"><span class="pre">more</span></code>, <code class="docutils literal notranslate"><span class="pre">less</span></code>, and <code class="docutils literal notranslate"><span class="pre">which</span></code>. These are some additional, extremely useful shell commands.</p>
</div>
</section>
<section id="redirecting-inputs-and-outputs">
<p><strong>Redirecting inputs and outputs.</strong> One of the cool things we can do with a shell is rewire a program’s inputs and outputs from the terminal (i.e., the default) to a file or even another program, which is exactly what we want to do in our second task. To illustrate, let’s play with the <code class="docutils literal notranslate"><span class="pre">echo</span></code> command, which will print whatever are its input parameters to the terminal.<a class="footnote-reference brackets" href="#fn8" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll">chap13$ echo hi there
</span>hi there
</pre></div>
</div>
<p>To change this default output location, we specify <em>output redirection</em>, which in the shell involves the greater-than character (<code class="docutils literal notranslate"><span class="pre">&gt;</span></code>).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll">chap13$ echo hi there &gt; data/out.txt
</span><span class="hll">chap13$ cat data/out.txt
</span>hi there
</pre></div>
</div>
<p>We just told <code class="docutils literal notranslate"><span class="pre">echo</span></code> to send its output to a file called <code class="docutils literal notranslate"><span class="pre">out.txt</span></code> in the subdirectory called <code class="docutils literal notranslate"><span class="pre">data</span></code>. If your shell gave you an error, make sure that <code class="docutils literal notranslate"><span class="pre">data</span></code> folder exists in your working directory.<a class="footnote-reference brackets" href="#fn9" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a> The program <code class="docutils literal notranslate"><span class="pre">cat</span></code>, which I mentioned earlier as one of several useful programs you should learn, prints the contents of the file that’s named as its input parameter. It helps us to verify that the output redirection did what I said it would.</p>
<div class="admonition-you-try-it admonition">
<p class="admonition-title">You Try It</p>
<p>Type <code class="docutils literal notranslate"><span class="pre">cat</span></code> at the shell prompt and hit return. Now type something and hit return. When <code class="docutils literal notranslate"><span class="pre">cat</span></code> isn’t given an input file, it defaults to reading what you type in the terminal window and then prints that. When you’re done playing, type Ctrl-D (i.e., hold the control key and then push the <code class="docutils literal notranslate"><span class="pre">d</span></code> key) to terminate the execution of <code class="docutils literal notranslate"><span class="pre">cat</span></code>.</p>
</div>
<p>You’ve now seen that <code class="docutils literal notranslate"><span class="pre">cat</span></code> can grab data from: (1) a file (in the same way our scripts open files to read their contents); or (2) from what we type at the terminal. But we can also mix these two things so that <code class="docutils literal notranslate"><span class="pre">cat</span></code> reads the contents of a file as if we were typing its contents at the terminal. To do this, we use the input redirection character (<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll">chap13$ cat &lt; data/out.txt
</span>hi there
</pre></div>
</div>
</section>
<section id="which-output">
<p><strong>Which output?</strong> With this knowledge, let’s try to capture the output of the Python interpreter when run on our broken script, which itself takes no input.</p>
<div class="admonition-you-try-it admonition">
<p class="admonition-title">You Try It</p>
<p>Run <code class="docutils literal notranslate"><span class="pre">python3</span> <span class="pre">broken.py</span> <span class="pre">&gt;</span> <span class="pre">out.txt</span></code>. What was printed to the terminal and what did you find in the file <code class="docutils literal notranslate"><span class="pre">out.txt</span></code>?<a class="footnote-reference brackets" href="#fn10" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a></p>
</div>
<p>You just learned that the Python interpreter does not print its execution output and its error messages using same mechanism. If we want to capture a program’s error output, we have to use a different redirect symbol: <code class="docutils literal notranslate"><span class="pre">2&gt;</span></code> where the <code class="docutils literal notranslate"><span class="pre">2</span></code> stands for <em>file descriptor 2</em>. On a Unix-like system,</p>
<ul class="simple">
<li><p><em>file descriptor 0</em> is called <em>stdin</em> and, by default, it is wired to the terminal;</p></li>
<li><p><em>file descriptor 1</em> is called <em>stdout</em> and, by default, it is wired to the terminal;</p></li>
<li><p><em>file descriptor 2</em> is called <em>stderr</em> and, by default, it is wired to the terminal; and</p></li>
<li><p>file descriptors numbered greater than 2 are allocated to the files you open using a command like Python’s built-in <code class="docutils literal notranslate"><span class="pre">open</span></code>.</p></li>
</ul>
<p>You can learn a lot more about such things by reading the documentation for your favorite shell program or take a class in systems programming. All we care about is that we now know how to capture the error message we want to rewrite:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll">chap13$ python3 broken.py &gt; out.txt 2&gt; out2.txt
</span><span class="hll">chap13$ cat out.txt
</span>[&#39;this&#39;, &#39;is&#39;, &#39;a&#39;, &#39;test&#39;]
[&#39;his&#39;, &#39;is&#39;, &#39;another&#39;, &#39;test&#39;]
<span class="hll">chap13$ cat out2.txt
</span>Traceback (most recent call last):
  File &quot;/home/runner/chap13/broken.py&quot;, line 23, in &lt;module&gt;
    main()
  File &quot;/home/runner/chap13/broken.py&quot;, line 20, in main
    f_undef_name()
  File &quot;/home/runner/chap13/broken.py&quot;, line 5, in f_undef_name
    print(undef_name)
NameError: name &#39;undef_name&#39; is not defined. Did you mean: &#39;f_undef_name&#39;?
</pre></div>
</div>
</section>
<section id="pattern-matching">
<p><strong>Pattern matching.</strong> With the second task understood, we turn to the third, which asks that we translate the error message that the Python interpreter produced into the one we want our user to see. To do this, we must: (1) recognize the patterns the interpreter uses in its error message; (2) grab the important data in these patterns that we want to use in our rewritten error message; and then (3) produce our error message with these data.</p>
<p>Recognizing and exploiting patterns is a huge piece of computational thinking. We’ve already seen the power of patterns when we turned a divide-and-conquer problem into a recursive procedure. Here are a few other examples of applications that use pattern matching:</p>
<ul class="simple">
<li><p>If your job requires you to use computers to process data, you’ll use a wide variety of tools built by computer scientists to find and exploit the patterns in your data (e.g., in physical, biological, or financial data).</p></li>
<li><p>If you want your application to converse with a human, you’ll use natural-language tools that exploit the patterns found in human languages.</p></li>
<li><p>If you want to scrape data from a bunch of websites around the internet, you’ll program your scraper to look for patterns on the websites it visits to identify the data it should capture.</p></li>
<li><p>Even the syntax highlighter in your IDE uses pattern-matching tools to know which text to highlight in what color.</p></li>
</ul>
</section>
<section id="wildcards-in-the-shell">
<p><strong>Wildcards in the shell.</strong> We learned to use <code class="docutils literal notranslate"><span class="pre">ls</span></code> to list all the files and directories in our working directory, but what if we wanted to list just those files or directories with names matching a particular pattern? For example, what if we wanted to list all the Python scripts in our working directory?</p>
<p>This is an example of pattern matching, and to express our desire to the <code class="docutils literal notranslate"><span class="pre">ls</span></code> command, we need a syntax (or ideally a <em>language</em>) to describe the patterns we want. In most shells, <em>wildcard characters</em> allow you to perform a simple kind of pattern matching. These wildcards aren’t literal values we want the shell to use, but like the joker in a deck of playing cards, characters that can take on any value. Let’s see how to solve the challenge I just posed using shell wildcards.</p>
<p>We know that Python scripts end with the extension <code class="docutils literal notranslate"><span class="pre">.py</span></code>, and therefore we want to tell <code class="docutils literal notranslate"><span class="pre">ls</span></code> that we want it to list only the filenames that end in <code class="docutils literal notranslate"><span class="pre">.py</span></code>. Or stated another way, we don’t care what comes before the <code class="docutils literal notranslate"><span class="pre">.py</span></code>. We can achieve this by typing <code class="docutils literal notranslate"><span class="pre">ls</span> <span class="pre">*.py</span></code> at the shell prompt.</p>
<p>In the shell, the star or asterisk character (<code class="docutils literal notranslate"><span class="pre">*</span></code>) is a wildcard character, and where you put it, it will <em>match zero or more characters</em>. So the pattern <code class="docutils literal notranslate"><span class="pre">*.py</span></code> says to the shell that you want all the filenames that end in <code class="docutils literal notranslate"><span class="pre">.py</span></code>.</p>
<div class="admonition-you-try-it admonition">
<p class="admonition-title">You Try It</p>
<p>Describe the kinds of filenames that <code class="docutils literal notranslate"><span class="pre">ls</span> <span class="pre">*e*.py</span></code> will list.<a class="footnote-reference brackets" href="#fn11" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></a></p>
</div>
<p>You can also ask the shell to <em>match any single character</em> using the <code class="docutils literal notranslate"><span class="pre">?</span></code> wildcard character.</p>
<div class="admonition-you-try-it admonition">
<p class="admonition-title">You Try It</p>
<p>Can you describe what this weird-looking command <code class="docutils literal notranslate"><span class="pre">ls</span> <span class="pre">*.??</span></code> asks of the shell?<a class="footnote-reference brackets" href="#fn12" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></a></p>
</div>
<p>Finally, you can use square brackets to <em>create your own special, single-character wildcard</em>. For instance, the command <code class="docutils literal notranslate"><span class="pre">ls</span> <span class="pre">out[0-9].txt</span></code> would match any file that starts with <code class="docutils literal notranslate"><span class="pre">out</span></code>, ends with <code class="docutils literal notranslate"><span class="pre">.txt</span></code>, and has a single digit between the <code class="docutils literal notranslate"><span class="pre">t</span></code> in <code class="docutils literal notranslate"><span class="pre">out</span></code> and the <code class="docutils literal notranslate"><span class="pre">.</span></code> of the file extension.</p>
</section>
<section id="regular-expressions">
<p><strong>Regular expressions.</strong> <em>Regular expressions</em> <em>(REs)</em> allow us to express a larger set of patterns for matching text than we can with shell wildcards. They are well studied in theoretical computer science, and they describe the set of <em>regular languages</em> found in that field’s classification of formal languages. They also bring us back to the concept of finite-state machines (FSMs) in that regular expressions can be algorithmically translated into a FSM, which can then be straightforwardly translated into code. If you are a power user of search engines or word processors, you have already been exploiting the power of REs.</p>
<p>To solve our third task, we’re going to use Python’s <code class="docutils literal notranslate"><span class="pre">re</span></code> library, which allows us to use REs to match and capture sequences of characters in strings.<a class="footnote-reference brackets" href="#fn13" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a></p>
</section>
<section id="finding-simple-words">
<p><strong>Finding simple words.</strong> Let’s start learning how to use the <code class="docutils literal notranslate"><span class="pre">re</span></code> library with another challenge: Define a RE that finds all the words in a string that contain nothing but the letters <code class="docutils literal notranslate"><span class="pre">a</span></code> to <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p>
<p>To solve this challenge, you need to know that the <code class="docutils literal notranslate"><span class="pre">re</span></code> library asks you to specify your REs as Python strings. This means that you can match the word <code class="docutils literal notranslate"><span class="pre">word</span></code> and only that word with the RE <code class="docutils literal notranslate"><span class="pre">'word'</span></code>. In other words, most characters match themselves. Or in detail, this RE says that a matching string must start with the letter <code class="docutils literal notranslate"><span class="pre">w</span></code>, be followed by the letter <code class="docutils literal notranslate"><span class="pre">o</span></code> and then <code class="docutils literal notranslate"><span class="pre">r</span></code> and finally <code class="docutils literal notranslate"><span class="pre">d</span></code>.</p>
<p>But what if we wanted to match the words <code class="docutils literal notranslate"><span class="pre">word</span></code> or <code class="docutils literal notranslate"><span class="pre">cord</span></code> or <code class="docutils literal notranslate"><span class="pre">ford</span></code>? As we saw with shell wildcards, REs allow you to use square brackets to designate a range of letters that match a single letter in the input string. Our RE would become <code class="docutils literal notranslate"><span class="pre">'[cfw]ord'</span></code>.</p>
<p>You can also use a dash in the square brackets to express a range of letters, as in:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'[a-z]'</span></code> matches any single letter in the range <code class="docutils literal notranslate"><span class="pre">a</span></code> to <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'[a-zA-Z]'</span></code> matches any upper- or lower-case letter.</p></li>
</ul>
<p>To match a <em>sequence of letters</em>, REs use the <code class="docutils literal notranslate"><span class="pre">*</span></code> and <code class="docutils literal notranslate"><span class="pre">+</span></code> characters. We just met the <code class="docutils literal notranslate"><span class="pre">*</span></code> in shell wildcards, but we will change its meaning slightly when we use it in a RE. In REs, the <code class="docutils literal notranslate"><span class="pre">*</span></code> and <code class="docutils literal notranslate"><span class="pre">+</span></code> characters are <em>metacharacters</em> that they don’t match their literal character equivalents nor are they wildcards. Instead, they specify how many times <em>the previous character</em> must be matched.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">*</span></code> means zero or more times.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">+</span></code> means one or more times.</p></li>
</ul>
<p>So, to match a word containing the letters <code class="docutils literal notranslate"><span class="pre">a-z</span></code>, you’d write the RE pattern <code class="docutils literal notranslate"><span class="pre">'[a-z]+'</span></code>. This pattern ends its matching when the next character is something other than <code class="docutils literal notranslate"><span class="pre">a-z</span></code>, e.g., a space.</p>
<div class="admonition-you-try-it admonition">
<p class="admonition-title">You Try It</p>
<p>Take a moment and run the script <code class="docutils literal notranslate"><span class="pre">play.py</span></code>, which you can find in this chapter’s code distribution. When you start running it (i.e., type <code class="docutils literal notranslate"><span class="pre">python3</span> <span class="pre">play.py</span></code> at the shell prompt), it will ask you for a RE, which you type without any surrounding quotes. Try it with the REs we’ve discussed: <code class="docutils literal notranslate"><span class="pre">word</span></code>; <code class="docutils literal notranslate"><span class="pre">[cfw]ord</span></code>; <code class="docutils literal notranslate"><span class="pre">[a-z]</span></code>; <code class="docutils literal notranslate"><span class="pre">[a-zA-Z]</span></code>; and <code class="docutils literal notranslate"><span class="pre">[a-z]+</span></code>. Once you’ve specified a RE, <code class="docutils literal notranslate"><span class="pre">play.py</span></code> repeatedly prompts you for a string, and given one, the script tells you whether that string is in the language of the RE (i.e., whether that string satisfies the pattern specified by the RE). For example, <code class="docutils literal notranslate"><span class="pre">ford</span></code> satisfies the pattern <code class="docutils literal notranslate"><span class="pre">[cfw]ord</span></code> but <code class="docutils literal notranslate"><span class="pre">lord</span></code> doesn’t. <code class="docutils literal notranslate"><span class="pre">m</span></code> satisfies the pattern <code class="docutils literal notranslate"><span class="pre">[a-z]</span></code> but <code class="docutils literal notranslate"><span class="pre">me</span></code> doesn’t. <code class="docutils literal notranslate"><span class="pre">word</span></code> satisfies the pattern <code class="docutils literal notranslate"><span class="pre">[a-z]+</span></code> but <code class="docutils literal notranslate"><span class="pre">this</span> <span class="pre">word</span></code> doesn’t. Do you see why <code class="docutils literal notranslate"><span class="pre">this</span> <span class="pre">word</span></code> doesn’t?<a class="footnote-reference brackets" href="#fn14" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>14<span class="fn-bracket">]</span></a> Try your own REs and strings. When you want to stop playing with the RE you specified, type <code class="docutils literal notranslate"><span class="pre">quit</span></code> at the <code class="docutils literal notranslate"><span class="pre">String:</span></code> prompt. Rerun the script to try another RE.</p>
</div>
</section>
<section id="matching-metacharacters">
<p><strong>Matching metacharacters.</strong> You might be wondering what you’d do if you wanted to match a literal <code class="docutils literal notranslate"><span class="pre">*</span></code> or <code class="docutils literal notranslate"><span class="pre">+</span></code> (or any other metacharacter). The answer is that you escape the character with a leading backslash. For instance, to match <code class="docutils literal notranslate"><span class="pre">2+3</span></code>, you’d like to write the RE <code class="docutils literal notranslate"><span class="pre">'2\+3'</span></code>.</p>
<div class="admonition-you-try-it admonition">
<p class="admonition-title">You Try It</p>
<p>Feed the RE <code class="docutils literal notranslate"><span class="pre">2\+3</span></code> to <code class="docutils literal notranslate"><span class="pre">play.py</span></code> and verify that it matches the string <code class="docutils literal notranslate"><span class="pre">2+3</span></code>. What strings does the RE <code class="docutils literal notranslate"><span class="pre">2+3</span></code> match?<a class="footnote-reference brackets" href="#fn15" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></a></p>
</div>
<p>The script <code class="docutils literal notranslate"><span class="pre">play.py</span></code> prompts you for a RE and captures what you type as a string.<a class="footnote-reference brackets" href="#fn16" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>16<span class="fn-bracket">]</span></a> But in a moment, we’ll start writing REs inside a Python script, and when we do, we have to be careful because the backslash character has meaning in a Python string literal (recall that <code class="docutils literal notranslate"><span class="pre">re</span></code> library has us use strings to specify a RE). Thus, we have to backslash any backslashes to transmit them through a Python string literal to the RE engine.</p>
<p>To minimize what’s called “The Backslash Plague”<a class="footnote-reference brackets" href="#fn17" id="id17" role="doc-noteref"><span class="fn-bracket">[</span>17<span class="fn-bracket">]</span></a> I’ll sometimes specify our RE pattern strings in <em>Python’s raw string notation</em>, which keeps our slashes meant for the RE engine from multiplying. For a straightforward RE like <code class="docutils literal notranslate"><span class="pre">'[a-z]+'</span></code>, I won’t bother with the raw string notation, since using it doesn’t clarify anything (this RE would be <code class="docutils literal notranslate"><span class="pre">r'[a-z]+')</span></code>. But I’ll use it for REs with backslashes (e.g., the RE pattern matching a single asterisk character <code class="docutils literal notranslate"><span class="pre">*</span></code> goes from <code class="docutils literal notranslate"><span class="pre">'\\*'</span></code> to <code class="docutils literal notranslate"><span class="pre">r'\*'</span></code>).</p>
<div class="admonition-you-try-it admonition">
<p class="admonition-title">You Try It</p>
<p>What RE do you give to <code class="docutils literal notranslate"><span class="pre">play.py</span></code> to match a single <code class="docutils literal notranslate"><span class="pre">*</span></code> (and no other string)?<a class="footnote-reference brackets" href="#fn18" id="id18" role="doc-noteref"><span class="fn-bracket">[</span>18<span class="fn-bracket">]</span></a> If you find it hard to know what RE to type, don’t worry because everyone does at first. There are two reasons for this: (1) Most of us don’t think about patterns in our daily life; we think about instances of patterns. (2) “The Backslash Plague” results from the interaction of two different languages (i.e., Python and REs) that brought together in our scripts.</p>
</div>
</section>
<section id="using-res">
<p><strong>Using REs.</strong> Now that we know how to specify a RE using the <code class="docutils literal notranslate"><span class="pre">re</span></code> library, how do we use it to find instances of a pattern in an input string? Well, there are two ways to do it:</p>
<ol class="arabic simple">
<li><p>If you plan to use your pattern in multiple statements, you’ll want to <em>compile your RE into a pattern object</em>. You’d then <em>use the methods of this pattern object</em> to find instances of the pattern in strings without having to continually restate the RE.</p></li>
<li><p>You can also <em>use a function from the</em> <code class="docutils literal notranslate"><span class="pre">re</span></code> <em>library</em> to which you provide a RE and a string as parameters. This shortcut works well when you don’t need to restate the RE in a later call to the <code class="docutils literal notranslate"><span class="pre">re</span></code> library.</p></li>
</ol>
<p>In case those words don’t make sense, the following applies these two approaches to our word-matching challenge. Both use the RE <code class="docutils literal notranslate"><span class="pre">'[a-z]+'</span></code> on the string <code class="docutils literal notranslate"><span class="pre">s1</span></code>, and both return this list of matches: <code class="docutils literal notranslate"><span class="pre">['this',</span> <span class="pre">'is',</span> <span class="pre">'a',</span> <span class="pre">'test']</span></code>.</p>
<div class="admonition-you-try-it admonition">
<p class="admonition-title">You Try It</p>
<p>Run the following code blocks in the interactive Python interpreter. Feel free to experiment with different REs and strings.</p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="c1">### Setup for the following examples</span>
<span class="linenos">2</span><span class="kn">import</span> <span class="nn">re</span>
<span class="linenos">3</span>
<span class="linenos">4</span><span class="n">s1</span> <span class="o">=</span> <span class="s1">&#39;this is a test&#39;</span>
<span class="linenos">5</span><span class="n">s2</span> <span class="o">=</span> <span class="s1">&#39;This is another test.&#39;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="c1"># Build and use a pattern object</span>
<span class="linenos">2</span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[a-z]+&#39;</span><span class="p">)</span>
<span class="linenos">3</span><span class="n">p</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="c1"># Just use an RE function</span>
<span class="linenos">2</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[a-z]+&#39;</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
</pre></div>
</div>
<p>Besides <code class="docutils literal notranslate"><span class="pre">findall</span></code>, we’ll also use the <code class="docutils literal notranslate"><span class="pre">match</span></code> and <code class="docutils literal notranslate"><span class="pre">search</span></code> functionality of the <code class="docutils literal notranslate"><span class="pre">re</span></code> library, which both return a <code class="docutils literal notranslate"><span class="pre">re.Match</span></code> object if there’s a match and <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise. On a successful match, the <code class="docutils literal notranslate"><span class="pre">re.Match</span></code> object contains the matching characters and where in the input string you can find these characters. <code class="docutils literal notranslate"><span class="pre">match</span></code> succeeds if the pattern appears at <em>the start</em> of the input string, and <code class="docutils literal notranslate"><span class="pre">search</span></code> succeeds if the pattern appears <code class="docutils literal notranslate"><span class="pre">anywhere</span></code> in the input string.</p>
<p>Here are some examples using the test strings <code class="docutils literal notranslate"><span class="pre">s1</span></code> and <code class="docutils literal notranslate"><span class="pre">s2</span></code>. Think about what they’ll do and then run them to check your thinking. This functionality isn’t easy to pick up, and so don’t get discouraged if you find it confusing. I certainly do.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="c1"># Match succeeds and a re.Match object is returned</span>
<span class="linenos">2</span><span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="c1"># Match fails because of the starting capital letter</span>
<span class="linenos">2</span><span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="o">==</span> <span class="kc">None</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="c1"># Search succeeds and a re.Match object is returned</span>
<span class="linenos">2</span><span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="c1"># Another more interesting search example</span>
<span class="linenos">2</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;is&#39;</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="c1"># What&#39;s the result returned from this statement?</span>
<span class="linenos">2</span><span class="n">p</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
</pre></div>
</div>
<p>We can capture capital letters either by changing our RE or by changing the default of the optional argument <code class="docutils literal notranslate"><span class="pre">flags</span></code><a class="footnote-reference brackets" href="#fn19" id="id19" role="doc-noteref"><span class="fn-bracket">[</span>19<span class="fn-bracket">]</span></a> to <code class="docutils literal notranslate"><span class="pre">re.compile</span></code> and the library’s other functions:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="c1"># Change the RE</span>
<span class="linenos">2</span><span class="n">p2</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[a-zA-Z]+&#39;</span><span class="p">)</span>
<span class="linenos">3</span><span class="n">p2</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="c1"># Leave the RE alone and change the `flags` parameter</span>
<span class="linenos">2</span><span class="n">p3</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[a-z]+&#39;</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
<span class="linenos">3</span><span class="n">p3</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="finding-filenames">
<p><strong>Finding filenames.</strong> Okay! With the basics of the <code class="docutils literal notranslate"><span class="pre">re</span></code> library understood, we’re ready to use patterns to change the Python interpreter’s error message into one that we’d prefer to read. Let’s again take this a step at time and first use REs to grab the filenames mentioned in the interpreter’s error output.</p>
<p>Notice that the Python interpreter’s error message contains absolute paths:</p>
<p><code class="docutils literal notranslate"><span class="pre">File</span> <span class="pre">&quot;/home/runner/chap13/broken.py&quot;,</span> <span class="pre">line</span> <span class="pre">23,</span> <span class="pre">in</span> <span class="pre">&lt;module&gt;</span></code></p>
<p>Because all the scripts we write appear in our working directory, the working directory’s path is unnecessary and distracting information. We might as well delete it, shortening any absolute paths involving the working directory into nothing more than the filename. In other words, if <code class="docutils literal notranslate"><span class="pre">/home/runner/chap13</span></code> is our working directory, we’ll grab <code class="docutils literal notranslate"><span class="pre">broken.py</span></code> from <code class="docutils literal notranslate"><span class="pre">/home/runner/chap13/broken.py</span></code> and discard the rest.</p>
<p>Let’s write a function called <code class="docutils literal notranslate"><span class="pre">get_fname</span></code> that does this. It will contain something like the RE we just used to capture words containing both capital and small letters, i.e., <code class="docutils literal notranslate"><span class="pre">'[a-zA-Z]+'</span></code>. But because our file and directory names can also include digits and the underscore (<code class="docutils literal notranslate"><span class="pre">_</span></code>) character, we’ll use a new metacharacter <code class="docutils literal notranslate"><span class="pre">\w</span></code>, which is a shorthand for <code class="docutils literal notranslate"><span class="pre">[a-zA-Z0-9_]</span></code>.</p>
<p>Our RE is now <code class="docutils literal notranslate"><span class="pre">r'\w+'</span></code>, which can match filenames without any file extension. The filenames in the interpreter’s error message are all Python scripts, and we want to include in the match the extension <code class="docutils literal notranslate"><span class="pre">.py</span></code>. The only tricky bit here is that the period character is a metacharacter equivalent to the shell wildcard <code class="docutils literal notranslate"><span class="pre">?</span></code>: In REs, the period character matches any single character except a newline. Since we want to match an actual period, we’ll escape it.</p>
<p>Our RE has become <code class="docutils literal notranslate"><span class="pre">r'\w+\.py'</span></code>. So far so good, but what if a directory name in the absolute path matches this pattern? We don’t want that.<a class="footnote-reference brackets" href="#fn20" id="id20" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a> We want only the last component of a file’s absolute path, which is its filename. We can specify this in our RE by using yet another metacharacter: the dollar sign (<code class="docutils literal notranslate"><span class="pre">$</span></code>). This metacharacter introduces us to a new idea and that’s the matching of <em>a point in a string</em>. A dollar sign in a RE means that we want to match the end of a string or the point just before the next newline character, which is where we’ll find the filename.</p>
<p>The RE <code class="docutils literal notranslate"><span class="pre">r'\w+\.py$'</span></code> will successfully match the kinds of filenames we use and pluck them from the end of the input strings. Let’s use the <code class="docutils literal notranslate"><span class="pre">re.search</span></code> function from the <code class="docutils literal notranslate"><span class="pre">re</span></code> library so that we can get some practice with it and learn about a useful method on <code class="docutils literal notranslate"><span class="pre">re.Match</span></code> objects. Here’s the code for our <code class="docutils literal notranslate"><span class="pre">get_fname</span></code> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">24</span><span class="c1">### chap13/rewrite.py</span>
<span class="linenos">25</span><span class="k">def</span> <span class="nf">get_fname</span><span class="p">(</span><span class="n">fullpath</span><span class="p">):</span>
<span class="linenos">26</span><span class="w">    </span><span class="sd">&#39;&#39;&#39;Strip full pathname down to just the filename&#39;&#39;&#39;</span>
<span class="linenos">27</span>    <span class="n">fname</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\w+\.py)$&#39;</span><span class="p">,</span> <span class="n">fullpath</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="linenos">28</span>    <span class="k">return</span> <span class="n">fname</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="c1">### Test get_fname</span>
<span class="linenos">2</span><span class="n">path</span> <span class="o">=</span> <span class="s1">&#39;/home/runner/chap13/broken.py&#39;</span>
<span class="linenos">3</span><span class="n">get_fname</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
</pre></div>
</div>
<p>There are two things you should note in this code. I added a pair of parentheses around the part of the RE that matched the filename. Parentheses are RE metacharacters that create something called <em>groups</em>, and the value of a group is whatever the RE in the parentheses matches, if anything. Here, I capture the entire set of matching characters, but I could have captured just a part of the match in the parentheses. We’ll use that functionality in a moment.</p>
<p>To access the match inside a set of parentheses, you use the <code class="docutils literal notranslate"><span class="pre">group</span></code> method on the returned <code class="docutils literal notranslate"><span class="pre">re.Match</span></code> object. The index for the first set of parentheses is <code class="docutils literal notranslate"><span class="pre">1</span></code>, the second <code class="docutils literal notranslate"><span class="pre">2</span></code>, and so forth. The index <code class="docutils literal notranslate"><span class="pre">0</span></code> is special; it returns the entire match, which is all we need in this example.</p>
<p>Don’t worry if line 27 looks like a bunch of gobbly goop to you right now. It will get easier for you to read with practice. And then time will pass and you’ll forget the details, but again, that’s ok. You will remember them with a refreshing read of the documentation.</p>
</section>
<section id="a-promise-fulfilled">
<p><strong>A promise fulfilled.</strong> In Chapter 10, we built a book index that used a function called <code class="docutils literal notranslate"><span class="pre">get_wordlist</span></code> to turn a string into a list of words, and I promised to explain how this function worked. Since it uses the <code class="docutils literal notranslate"><span class="pre">re</span></code> library, we’re now ready to understand how to turn a line like <code class="docutils literal notranslate"><span class="pre">'And</span> <span class="pre">Mrs.</span> <span class="pre">Smith</span> <span class="pre">said,</span> <span class="pre">&quot;I\'m</span> <span class="pre">the</span> <span class="pre">best!&quot;'</span></code> into the wordlist <code class="docutils literal notranslate"><span class="pre">['And',</span> <span class="pre">'Mrs',</span> <span class="pre">'Smith',</span> <span class="pre">'said',</span> <span class="pre">&quot;I'm&quot;,</span> <span class="pre">'the',</span> <span class="pre">'best']</span></code>. This task is not easy. Take a moment to consider how you’d mechanically remove apostrophes and dashes except when they’re part of a contraction or a hyphenated word. As you can see below, <code class="docutils literal notranslate"><span class="pre">get_wordlist</span></code> accomplishes this challenge in very few statements. This is the power of the <code class="docutils literal notranslate"><span class="pre">re</span></code> library.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">16</span><span class="c1">### chap10/index32.py</span>
<span class="linenos">17</span><span class="kn">import</span> <span class="nn">re</span>
<span class="linenos">18</span><span class="kn">import</span> <span class="nn">string</span>
<span class="linenos">19</span>
<span class="linenos">20</span><span class="k">def</span> <span class="nf">get_wordlist</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
<span class="linenos">21</span>    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
<span class="linenos">22</span>    <span class="k">return</span> <span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;^[</span><span class="si">{0}</span><span class="s1">]+|[</span><span class="si">{0}</span><span class="s1">]+$&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">punctuation</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
<span class="linenos">23</span>            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
</pre></div>
</div>
<p>We’ll begin by dispensing with line 21, catches a case (the use of an en-dash) not handled by the RE expression in line 22. You should understand it from our earlier work with <code class="docutils literal notranslate"><span class="pre">str.replace</span></code>.</p>
<p>Line 22, which continues on line 23, is where the interesting stuff happens. To understand this statement, first recognize that the outermost square brackets define a <em>Python list comprehension</em>, which is a shorthand for creating a new list from the values in an existing list. The “existing list” comes from a straightforward <code class="docutils literal notranslate"><span class="pre">str.split</span></code> of the input line, which removes whitespace but leaves “words” like <code class="docutils literal notranslate"><span class="pre">'best!&quot;'</span></code>, which you’ll see if you run the next code block.</p>
<div class="admonition-you-try-it admonition">
<p class="admonition-title">You Try It</p>
<p>Run the next several code blocks with the interactive Python interpreter. This work will strengthen your understanding. Feel free to change them and see what happens.</p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="n">line</span> <span class="o">=</span> <span class="s1">&#39;And Mrs. Smith said, &quot;I</span><span class="se">\&#39;</span><span class="s1">m the best!&quot;&#39;</span>
<span class="linenos">2</span><span class="p">[</span><span class="n">w</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
</pre></div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">get_wordlist</span></code>, each <code class="docutils literal notranslate"><span class="pre">w</span></code> isn’t lowered, but fed to another function in the <code class="docutils literal notranslate"><span class="pre">re</span></code> library. The <code class="docutils literal notranslate"><span class="pre">re.sub</span></code> function uses the RE (its first parameter) to identify substrings of the input string (its third parameter) and then replaces these identified substrings with a replacement string (its second parameter). Here’s a simpler example of <code class="docutils literal notranslate"><span class="pre">re.sub</span></code> in action:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;[a-zA-Z]+&#39;</span><span class="p">,</span> <span class="s1">&#39;WORD&#39;</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
</pre></div>
</div>
<p>Now all we have left to understand is the RE in <code class="docutils literal notranslate"><span class="pre">get_wordlist</span></code>, but even this is complicated because it uses a method on strings to reduce what we have to write in the RE string! Let’s replace the <code class="docutils literal notranslate"><span class="pre">{0}</span></code> syntax and the <code class="docutils literal notranslate"><span class="pre">str.format</span></code> method with a familiar character set so that we can focus on the two new RE metacharacters: <code class="docutils literal notranslate"><span class="pre">^</span></code> and <code class="docutils literal notranslate"><span class="pre">|</span></code>.</p>
<ul class="simple">
<li><p>^ : This metacharacter is like <code class="docutils literal notranslate"><span class="pre">$</span></code>, but it matches <em>the point at the start of the string</em>.</p></li>
<li><p>| : This metacharacter represents <em>a logical OR</em>. If the pattern before the vertical bar matches, the pattern after it isn’t tested. If the first doesn’t match, the second is tried.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;^[a-zA-Z]+|[a-zA-Z]+$&#39;</span><span class="p">,</span> <span class="s1">&#39;WORD&#39;</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
</pre></div>
</div>
<p>If you look carefully at the result of this code block, you’ll see that the only difference between this and the previous list comprehension is the fifth element in the returned lists. The previous code block produced <code class="docutils literal notranslate"><span class="pre">'&quot;WORD\'WORD'</span></code> while this one produced <code class="docutils literal notranslate"><span class="pre">'&quot;I\'WORD'</span></code>, and in both cases the input <code class="docutils literal notranslate"><span class="pre">w</span></code> was <code class="docutils literal notranslate"><span class="pre">'&quot;I\'m'</span></code>. The <code class="docutils literal notranslate"><span class="pre">'I'</span></code> remains in the second case because neither of the two REs, before or after the vertical bar (<code class="docutils literal notranslate"><span class="pre">|</span></code>), matches this letter; it isn’t a word (i.e., <code class="docutils literal notranslate"><span class="pre">'[a-zA-Z]+'</span></code>) at either the start or the end of the string <code class="docutils literal notranslate"><span class="pre">w</span></code>.</p>
<p>But replacing words is not what we want to do in <code class="docutils literal notranslate"><span class="pre">get_wordlist</span></code>. This function is supposed to delete punctuation that isn’t the apostrophe in a contraction or the hyphen in a hyphenated word. And this is where the <code class="docutils literal notranslate"><span class="pre">str.format</span></code> method and the <code class="docutils literal notranslate"><span class="pre">{0}</span></code> syntax comes in. While messy, this is just another way to write a formatted string literal in Python, which we’ve repeatedly done by placing an <code class="docutils literal notranslate"><span class="pre">f</span></code> character before our string literals. The following are equivalent:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="n">num</span> <span class="o">=</span> <span class="mi">42</span>
<span class="linenos">2</span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;answer = </span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="linenos">3</span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;answer = </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num</span><span class="p">))</span>
</pre></div>
</div>
<p>As you can see, we’re just replacing every <code class="docutils literal notranslate"><span class="pre">{0}</span></code> in the string with the first parameter to <code class="docutils literal notranslate"><span class="pre">format</span></code>. The parameter we use in <code class="docutils literal notranslate"><span class="pre">get_wordlist</span></code> is <code class="docutils literal notranslate"><span class="pre">string.punctuation</span></code>, which the <code class="docutils literal notranslate"><span class="pre">string</span></code> library nicely defines as a string containing every punctuation symbol.<a class="footnote-reference brackets" href="#fn21" id="id21" role="doc-noteref"><span class="fn-bracket">[</span>21<span class="fn-bracket">]</span></a> Now think about what our RE would look like if we replace both instances of <code class="docutils literal notranslate"><span class="pre">{0}</span></code> with the value of <code class="docutils literal notranslate"><span class="pre">string.punctuation</span></code>. Yes, the RE would be even harder to read!</p>
<p>With the details explained, I’ll say in English what this complicated statement does: It replaces sequences of one or more punctuation characters at the start or end of a “word,” as produced by <code class="docutils literal notranslate"><span class="pre">str.split</span></code>, with an empty string. That’s it. I hope you now appreciate the incredible power of the <code class="docutils literal notranslate"><span class="pre">re</span></code> library.</p>
<div class="admonition-you-try-it admonition">
<p class="admonition-title">You Try It</p>
<p>Feed your own test strings to <code class="docutils literal notranslate"><span class="pre">get_wordlist</span></code>, by changing the definition of <code class="docutils literal notranslate"><span class="pre">line</span></code> in the following code block. There are still a few English grammatical structures that <code class="docutils literal notranslate"><span class="pre">get_wordlist</span></code> doesn’t handle, but it handles a lot.</p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="n">line</span> <span class="o">=</span> <span class="s1">&#39;And Mrs. Smith said, &quot;I</span><span class="se">\&#39;</span><span class="s1">m the best!&quot;&#39;</span>
<span class="linenos">2</span><span class="n">get_wordlist</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="python-re-extensions">
<p><strong>Python RE extensions.</strong> We have all the pieces we need to complete Task 3: We can recognize patterns in the Python interpreter’s error message, grab the data we want, and use these data to compose our own, more readable error message. The script <code class="docutils literal notranslate"><span class="pre">rewrite.py</span></code>, which you can find in the book’s Github repo, contains a function named <code class="docutils literal notranslate"><span class="pre">rewrite_emsg</span></code> that takes the Python interpreter’s error message as its input parameter and prints on <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> our own rewritten error message.<a class="footnote-reference brackets" href="#fn22" id="id22" role="doc-noteref"><span class="fn-bracket">[</span>22<span class="fn-bracket">]</span></a></p>
<p>Behind the interface of <code class="docutils literal notranslate"><span class="pre">rewrite_emsg</span></code> is a lot of interesting work. Because I wanted information that currently exists at the end of the Python interpreter’s error message at the start of my error message, this function splits the processing of the input error message <code class="docutils literal notranslate"><span class="pre">e</span></code> into two pieces: (1) grab and process the “Traceback” lines, which is done in <code class="docutils literal notranslate"><span class="pre">process_traceback</span></code>; and (2) take some of what was learned from <code class="docutils literal notranslate"><span class="pre">process_traceback</span></code> and process and print the error followed by my rewritten traceback, which is done in <code class="docutils literal notranslate"><span class="pre">print_error</span></code> and aided by <code class="docutils literal notranslate"><span class="pre">print_stack</span></code>.</p>
<p>Understanding the code in <code class="docutils literal notranslate"><span class="pre">rewrite.py</span></code> is useful if you want to modify my error message, but even if you don’t, there is one aspect of how <code class="docutils literal notranslate"><span class="pre">process_traceback</span></code> works that’s worth highlighting. It deals with parentheses in REs, which I mentioned earlier but didn’t show you why they were really useful. I’ll do that now.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">28</span><span class="c1">### chap13/rewrite.py</span>
<span class="linenos">29</span><span class="kn">import</span> <span class="nn">re</span>
<span class="linenos">30</span>
<span class="linenos">31</span><span class="k">def</span> <span class="nf">process_traceback</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="linenos">32</span><span class="w">    </span><span class="sd">&#39;&#39;&#39;Highlight only the files in the current dir</span>
<span class="linenos">33</span><span class="sd">       * Expects index i to point to the &#39;Traceback&#39;</span>
<span class="linenos">34</span><span class="sd">         line in the Python error output.</span>
<span class="linenos">35</span><span class="sd">       * Returns a tuple:</span>
<span class="linenos">36</span><span class="sd">        - list of function frames;</span>
<span class="linenos">37</span><span class="sd">        - index i following the traceback block.</span>
<span class="linenos">38</span><span class="sd">    &#39;&#39;&#39;</span>
<span class="linenos">39</span>    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># skip &#39;Traceback&#39; line</span>
<span class="linenos">40</span>    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># stack frames</span>
<span class="linenos">41</span>    <span class="n">cwd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
<span class="linenos">42</span>
<span class="linenos">43</span>    <span class="c1"># Process each &#39;File&#39; line in traceback</span>
<span class="linenos">44</span>    <span class="k">while</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="mi">6</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;  File&#39;</span><span class="p">:</span>
<span class="linenos">45</span>        <span class="c1"># Define RE pattern and run match on current line</span>
<span class="linenos">46</span>        <span class="n">p</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;  File &quot;(?P&lt;fname&gt;.*)&quot;, line (?P&lt;lnno&gt;\d+), in (?P&lt;fun&gt;[\w&lt;&gt;]+)&#39;</span>
<span class="linenos">47</span>        <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="linenos">48</span>
<span class="linenos">49</span>        <span class="c1"># Record stack frames for scripts in our current</span>
<span class="linenos">50</span>        <span class="c1"># directory; ignore frames in libraries.</span>
<span class="linenos">51</span>        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;fname&#39;</span><span class="p">)[:</span><span class="nb">len</span><span class="p">(</span><span class="n">cwd</span><span class="p">)]</span> <span class="o">==</span> <span class="n">cwd</span><span class="p">:</span>
<span class="linenos">52</span>            <span class="n">stack</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">groupdict</span><span class="p">())</span>
<span class="linenos">53</span>
<span class="linenos">54</span>        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
<span class="linenos">55</span>        <span class="k">assert</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
<span class="linenos">56</span>
<span class="linenos">57</span>    <span class="c1"># i indicates where to continue processing in lines</span>
<span class="linenos">58</span>    <span class="k">return</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>
</pre></div>
</div>
<p>The three separate parentheses in the RE on line 46 allow me to extract three separate values from each match. The format of the content of each parenthesis pair quite cryptic at first glance. To read a grouping like <code class="docutils literal notranslate"><span class="pre">(?P&lt;lnno&gt;\d+)</span></code>, you should understand that:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">\d+</span></code> is the pattern we want to match. It uses another escape shorthand <code class="docutils literal notranslate"><span class="pre">\d</span></code> that matches one or more digits <code class="docutils literal notranslate"><span class="pre">0-9</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(?P&lt;lnno&gt;</span> <span class="pre">...)</span></code> acts like normal parentheses in that it creates a group, but the leading <code class="docutils literal notranslate"><span class="pre">(?P</span></code> creates it as a <em>named group</em>. In particular, <code class="docutils literal notranslate"><span class="pre">(?</span></code> means that we’re invoking an extension, and the <code class="docutils literal notranslate"><span class="pre">P</span></code> means it’s a Python extension. The <code class="docutils literal notranslate"><span class="pre">lnno</span></code> in the angle brackets is the name we want associated with this group.</p></li>
</ul>
<p>By naming the different parts extracted, you can see that I want the filename (<code class="docutils literal notranslate"><span class="pre">fname</span></code>), the line number (<code class="docutils literal notranslate"><span class="pre">lnno</span></code>), and function name (<code class="docutils literal notranslate"><span class="pre">fun</span></code>) from the match. Line 51 illustrates how to use these named values. The alternative is to use the index of where each match was expressed in the original RE, which you can imagine makes this code even harder to read and understand.</p>
</section>
<section id="putting-it-all-together">
<p><strong>Putting it all together.</strong> If we design <code class="docutils literal notranslate"><span class="pre">rewrite.py</span></code> to accept a parameter, and we use this parameter to indicate in which file we put the Python interpreter’s error message, we could type the following on the shell’s command line to capture and replace the interpreter’s message with ours:</p>
<p><code class="docutils literal notranslate"><span class="pre">python3</span> <span class="pre">broken.py</span> <span class="pre">2&gt;</span> <span class="pre">out2.txt;</span> <span class="pre">python3</span> <span class="pre">rewrite.py</span> <span class="pre">out2.txt;</span> <span class="pre">rm</span> <span class="pre">-f</span> <span class="pre">out2.txt</span></code></p>
<p>By placing a semicolon at the end of each command, the shell knows that it should: launch the command it read up to the semicolon; let this command finish; and then launch the next command. You can think of the semicolon as a way to build a task list for the shell. The task list we wrote above says:</p>
<ol class="arabic simple">
<li><p>Run the Python interpreter on <code class="docutils literal notranslate"><span class="pre">broken.py</span></code>, grab the <code class="docutils literal notranslate"><span class="pre">stderr</span></code> output, and put that output in <code class="docutils literal notranslate"><span class="pre">out2.txt</span></code>. Anything written by <code class="docutils literal notranslate"><span class="pre">broken.py</span></code> to <code class="docutils literal notranslate"><span class="pre">stdout</span></code> is displayed on the terminal.</p></li>
<li><p>When the work in (1) is done, run the Python interpreter on <code class="docutils literal notranslate"><span class="pre">rewrite.py</span></code>, which expects an input file containing an error message as its only input parameter. We give it <code class="docutils literal notranslate"><span class="pre">out2.txt</span></code> from the execution of <code class="docutils literal notranslate"><span class="pre">broken.py</span></code>. It rewrites the captured error message and prints the result to <code class="docutils literal notranslate"><span class="pre">stderr</span></code>, which is wired to the terminal in this command.</p></li>
<li><p>When the work in (2) is done, <code class="docutils literal notranslate"><span class="pre">rm</span></code> removes the file <code class="docutils literal notranslate"><span class="pre">out2.txt</span></code>. The <code class="docutils literal notranslate"><span class="pre">-f</span></code> flag says to do it silently. If you’ve set <code class="docutils literal notranslate"><span class="pre">rm</span></code> to request confirmation before deleting anything, it won’t under this flag, and if <code class="docutils literal notranslate"><span class="pre">rm</span></code> encounters an error (e.g., the file <code class="docutils literal notranslate"><span class="pre">out2.txt</span></code> doesn’t exist because the script fed to the Python interpreter in (1) didn’t contain an error), it won’t print a diagnostic message.</p></li>
</ol>
<div class="admonition-you-try-it admonition">
<p class="admonition-title">You Try It</p>
<p>Try this shell command line and its sequence of tasks. Try your own command line that includes semicolons.</p>
</div>
</section>
<section id="shell-pipes">
<p><strong>Shell pipes.</strong> While this command line with its sequence of tasks solves our problem, it is a lot to type. But we don’t have to type all this. We can have the shell and the Python interpreter do more of this work for us! For example, we can get rid of the file <code class="docutils literal notranslate"><span class="pre">out2.txt</span></code> (and thus the need for the <code class="docutils literal notranslate"><span class="pre">rm</span></code> command above) by sending the Python interpreter’s error output directly to <code class="docutils literal notranslate"><span class="pre">rewrite.py</span></code>. The shell doesn’t only support redirection of a program’s output to a file, but it also allows us to “wire” the output of one program directly to the input of another. You accomplish this with the shell’s pipe operator (<code class="docutils literal notranslate"><span class="pre">|</span></code>).</p>
<p>As a simple example of piping, imagine that I wanted to see the Python scripts in my working directory sorted by size, and I wanted the smallest scripts listed first. The <code class="docutils literal notranslate"><span class="pre">ls</span></code> command has an option <code class="docutils literal notranslate"><span class="pre">-l</span></code> that prints a lot of information for each item it lists, and most Unix-like systems come with a <code class="docutils literal notranslate"><span class="pre">sort</span></code> program. The <code class="docutils literal notranslate"><span class="pre">sort</span></code> program on my system has an option <code class="docutils literal notranslate"><span class="pre">-k</span></code> that allows me to indicate which column <code class="docutils literal notranslate"><span class="pre">sort</span></code> should use for ordering the input lines.<a class="footnote-reference brackets" href="#fn23" id="id23" role="doc-noteref"><span class="fn-bracket">[</span>23<span class="fn-bracket">]</span></a> Terrific! I just need to wire the output of <code class="docutils literal notranslate"><span class="pre">ls</span></code> into the input of <code class="docutils literal notranslate"><span class="pre">sort</span></code>, and my job is done.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll">chap13$ ls -l *.py | sort -k 5
</span>-rw-r--r--@ 1 profsmith  staff   340 Apr 12  2023 play.py
-rw-r--r--@ 1 profsmith  staff   416 Oct 31 11:34 broken.py
-rw-r--r--@ 1 profsmith  staff   584 Nov  3 19:10 python32.py
-rw-r--r--@ 1 profsmith  staff  4961 Nov  4 11:13 rewrite.py
</pre></div>
</div>
<p>Unfortunately, it’s possible but not as straightforward to wire the <code class="docutils literal notranslate"><span class="pre">stderr</span></code> of one program into the <code class="docutils literal notranslate"><span class="pre">stdin</span></code> of another, which is what we want to do. The following is the syntax to do it. It’s definitely shorter than our previous solution, but it is still not the elegant solution we want.</p>
<p><code class="docutils literal notranslate"><span class="pre">python3</span> <span class="pre">broken.py</span> <span class="pre">2&gt;</span> <span class="pre">&gt;(python3</span> <span class="pre">rewrite.py)</span></code></p>
</section>
<section id="scripting-what-the-shell-did">
<p><strong>Scripting what the shell did.</strong> To get the elegance we want, we’ll put the work we’ve been doing on the shell command line in a Python script. Why stop with a script that rewrites the Python interpreter’s error message when we can write a script that launches the interpreter on the script we want to run, captures the interpreter’s error output, and feeds that output to <code class="docutils literal notranslate"><span class="pre">rewrite.py</span></code>?</p>
<p>Let’s call this new script <code class="docutils literal notranslate"><span class="pre">python32.py</span></code>, and it will take as input the script we want the Python interpreter to run.</p>
<p><code class="docutils literal notranslate"><span class="pre">python3</span> <span class="pre">python32.py</span> <span class="pre">broken.py</span></code></p>
<p><a class="reference internal" href="#c13-fig1-ref"><span class="std std-numref">Figure 33</span></a>  illustrates how we want <code class="docutils literal notranslate"><span class="pre">python32.py</span></code> to operate. The first thing it will do is launch another process that runs the Python interpreter on its input parameter. The <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> of this launched process will be left untouched (i.e., it will default to the terminal). However, the launched process’s <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> will be configured to be a pipe back to <code class="docutils literal notranslate"><span class="pre">python32.py</span></code>. These three things are possible using Python’s <code class="docutils literal notranslate"><span class="pre">subprocess</span></code> library. We’ll then have <code class="docutils literal notranslate"><span class="pre">python32.py</span></code> grab the bytes transferred through the pipe, convert them into a string, and send this string to <code class="docutils literal notranslate"><span class="pre">rewrite_emsg</span></code>, which <code class="docutils literal notranslate"><span class="pre">python32.py</span></code> will import from <code class="docutils literal notranslate"><span class="pre">rewrite.py</span></code>. As we already know, <code class="docutils literal notranslate"><span class="pre">rewrite_emsg</span></code> prints its rewritten error message to <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>, but this is <code class="docutils literal notranslate"><span class="pre">python32.py</span></code>’s <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>, which is wired by default to the terminal. Tada!</p>
<figure class="align-default" id="c13-fig1-ref">
<img alt="_images/c13_fig1.png" src="_images/c13_fig1.png" />
<figcaption>
<p><span class="caption-number">Fig. 33 </span><span class="caption-text">A sketch of how we want our <code class="docutils literal notranslate"><span class="pre">python32.py</span></code> script to operate.</span><a class="headerlink" href="#c13-fig1-ref" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="concurrency">
<p><strong>Concurrency.</strong> Did you notice that there are two instances of the Python interpreter running in <a class="reference internal" href="#c13-fig1-ref"><span class="std std-numref">Figure 33</span></a>? There’s the one that runs <code class="docutils literal notranslate"><span class="pre">python32.py</span></code> and the one that script launches to run <code class="docutils literal notranslate"><span class="pre">broken.py</span></code> (or whatever is the input parameter to <code class="docutils literal notranslate"><span class="pre">python32.py</span></code>). This might remind you of the way we ran the client and server scripts in Chapter 5. Both involve the use of multiple processes, but in this case, we’re running two instances of the same program (i.e., the Python interpreter) on different inputs (i.e., the scripts we want interpreted).</p>
<p>The emphasis in our networking discussion was in <em>the communication between two processes</em>. In this chapter’s problem, we’re still interested in two processes communicating, but we’re using a different mechanism (i.e., pipes rather than the network). <code class="docutils literal notranslate"><span class="pre">python32.py</span></code> also launches the second script and controls how it interacts with the rest of our computer system. Both examples illustrate the concept of <em>concurrency</em> and some of its fascinating aspects.</p>
<p>We’ve spent a lot of time in this chapter talking about the shell, and there’s a concurrency tie to it too. When you ask the shell to run a program by typing a command at the shell prompt, it does something very much like we just did in launching a subprocess in <code class="docutils literal notranslate"><span class="pre">python32.py</span></code>. Not only do you now know more shell commands, but you also understand a bit about how it works!</p>
</section>
<section id="making-python32-look-like-python3">
<p><strong>Making python32 look like python3.</strong> The astute reader will point out that invoking the Python interpreter on <code class="docutils literal notranslate"><span class="pre">python32.py</span></code> is not the command I showed at the start of this chapter. It was <code class="docutils literal notranslate"><span class="pre">./python32</span> <span class="pre">broken.py</span></code>. So I owe you one more explanation of shell functionality: how to turn <code class="docutils literal notranslate"><span class="pre">python3</span> <span class="pre">python32</span></code> into <code class="docutils literal notranslate"><span class="pre">./python32</span></code>.</p>
<p>You can do this with any Python script you write that runs on a Unix-like system. It involves three small steps:</p>
<ol class="arabic simple">
<li><p>Tell the filesystem that your Python script is an executable.</p></li>
<li><p>Create a symbolic link to your Python script to lose the <code class="docutils literal notranslate"><span class="pre">.py</span></code> extension.</p></li>
<li><p>Add a line to the start of your script that tells the shell how to execute your file, since it can no longer even use the extension as a hint about the file’s contents.</p></li>
</ol>
<p>Step 1 modifies the metadata that the filesystem keeps about each file. We saw some of this metadata when we did <code class="docutils literal notranslate"><span class="pre">ls</span> <span class="pre">-l</span></code> earlier. The first 10 characters of a long listing are what are called <em>file mode bits</em>, and 9 of them indicate whether the file is <em>readable (r)</em>, <em>writable (w)</em>, or <em>executable (x)</em>. By default, data files are readable and writable by their owner<a class="footnote-reference brackets" href="#fn24" id="id24" role="doc-noteref"><span class="fn-bracket">[</span>24<span class="fn-bracket">]</span></a> but aren’t executable.</p>
<p>To make a file executable, you have to change its mode. The shell command we use to do this is <code class="docutils literal notranslate"><span class="pre">chmod</span></code>, which stands for “change file mode bits.” The following transcript shows how to use this command, and it illustrates the file mode bits before and after.<a class="footnote-reference brackets" href="#fn25" id="id25" role="doc-noteref"><span class="fn-bracket">[</span>25<span class="fn-bracket">]</span></a></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll">chap13$ ls -l python32.py
</span>-rw-r--r--@ 1 profsmith  staff   584 Nov  3 19:10 python32.py
<span class="hll">chap13$ chmod +x python32.py
</span>chap13$ ls -l python32.py
<span class="hll">-rwxr-xr-x@ 1 profsmith  staff   584 Nov  3 19:10 python32.py
</span></pre></div>
</div>
<p>Step 2 initially seems straightforward: We make a copy of our script (e.g., <code class="docutils literal notranslate"><span class="pre">cp</span> <span class="pre">python32.py</span> <span class="pre">python32</span></code>) or rename it (<code class="docutils literal notranslate"><span class="pre">mv</span> <span class="pre">python32.py</span> <span class="pre">python32</span></code>). Unfortunately, both are suboptimal solutions. The former creates two copies of the same file, and the latter means we won’t get syntax highlighting in the IDE (because it can’t read the <code class="docutils literal notranslate"><span class="pre">.py</span></code> extension and know it’s a Python file).</p>
<p>There is a better solution: Create an alias, which in Unix terminology is a <em>symbolic link</em>, using the <code class="docutils literal notranslate"><span class="pre">-s</span></code> option on the <code class="docutils literal notranslate"><span class="pre">ln</span></code> command.</p>
<p><code class="docutils literal notranslate"><span class="pre">ln</span> <span class="pre">-s</span> <span class="pre">python32.py</span> <span class="pre">python32</span></code></p>
<p>Now we can edit <code class="docutils literal notranslate"><span class="pre">python32.py</span></code> in our IDE with full color syntax highlighting while running scripts with <code class="docutils literal notranslate"><span class="pre">python32</span></code>. We have two names for the same file.</p>
<p>Step 3 requires us to tell the shell how to run our script in a manner that doesn’t have us invoke the Python interpreter on the shell’s command line. Note that all we did by setting the executable file permission bit was tell the shell that it’s ok to run this file as a command; the shell also needs to know what it should do to execute the file. By convention, the shell expects this information at the start of an executable file.<a class="footnote-reference brackets" href="#fn26" id="id26" role="doc-noteref"><span class="fn-bracket">[</span>26<span class="fn-bracket">]</span></a> This means that we need to put some directions for the shell at the start of <code class="docutils literal notranslate"><span class="pre">python32</span></code>. The format of these directions on Unix-like systems is as follows:</p>
<p><code class="docutils literal notranslate"><span class="pre">#!/usr/bin/env</span> <span class="pre">python3</span></code></p>
<p>This line starts with <a class="reference external" href="https://en.wikipedia.org/wiki/Shebang_(Unix)">a “shebang” sequence</a> (i.e., <code class="docutils literal notranslate"><span class="pre">#!</span></code>), and the rest of it is the way the shell invokes the interpreter program. With this information, the shell turns <code class="docutils literal notranslate"><span class="pre">./python32</span></code> back into <code class="docutils literal notranslate"><span class="pre">python3</span> <span class="pre">python32.py</span></code>. We now have a way to type one command (<code class="docutils literal notranslate"><span class="pre">./python32</span></code>) and the shell will launch the Python intepreter on a script (<code class="docutils literal notranslate"><span class="pre">python32.py</span></code>) that does all the work we had to previously write out on the shell’s command line. We’ve shimmed the Python interpreter and made it look like it’s producing our rewritten error message!</p>
<p>We began this chapter saying that the right tool will make our problems easy. Regular expressions were the right tool for grabbing the data we wanted out of the Python interpreter’s error messages, and the programming aspects of the shell were the right tool automating all we wanted done behind one simple command, which we built. We saw several ways to execute <code class="docutils literal notranslate"><span class="pre">rewrite.py</span></code>, and one of them turned out to be an elegant solution to our problem.</p>
<p>[Version 20240729]</p>
<hr class="footnotes docutils" />
<aside class="footnote brackets" id="fn1" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>The undefined name is one line 5 of `broken.py`.</p>
</aside>
<aside class="footnote brackets" id="fn2" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>This approach should remind you of the shimming operation we performed in Chapter 5, where we wanted to make only small changes to a library’s API or its operation. This same problem-solving approach is applicable with programs if you take advantage of the programmable nature of the shell (or whatever is the computational environment in which you run your programs).</p>
</aside>
<aside class="footnote brackets" id="fn3" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p>The shell is an example of a command line interface (CLI), where commands are expressed in text at a command prompt.</p>
</aside>
<aside class="footnote brackets" id="fn4" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p>Yes, you can ask the `man` command to describe itself (i.e., you’d type `man man`), or any other shell command.</p>
</aside>
<aside class="footnote brackets" id="fn5" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">5</a><span class="fn-bracket">]</span></span>
<p>In an absolute path, I’ve used forward slashes (`/`) to indicate where one folder’s name ends and the next begins. This is the convention for the operating system (OS) on which I’m running. Some OSes (e.g., Windows) use backward slashes (``) rather than forward slashes.</p>
</aside>
<aside class="footnote brackets" id="fn6" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">6</a><span class="fn-bracket">]</span></span>
<p>When I say built-in, I mean that the shell knows what to do based solely on the command name (e.g., when we type the command `echo`). It doesn’t search the filesystem looking for an executable file with this name.</p>
</aside>
<aside class="footnote brackets" id="fn7" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">7</a><span class="fn-bracket">]</span></span>
<p>Yes, that dollar sign is part of the shell variable name. In Chapter 1 under the section titled “Valid names in Python” I described the rules involved in creating valid variable names in Python. Basically, these names must start with a letter or an underscore character. In contrast, the shell has a different set of rules. For example, shell variables names must start with a dollar-sign character.</p>
</aside>
<aside class="footnote brackets" id="fn8" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">8</a><span class="fn-bracket">]</span></span>
<p>Notice that the shell considers `hi` and `there` to be literal strings and not shell variables, since they don’t start with a dollar sign. The shell’s syntax is different than Python’s!</p>
</aside>
<aside class="footnote brackets" id="fn9" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">9</a><span class="fn-bracket">]</span></span>
<p>Using output redirection will create the specified destination file if it doesn’t exist (and overwrite it if it does), but not any directories along the path.</p>
</aside>
<aside class="footnote brackets" id="fn10" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id10">10</a><span class="fn-bracket">]</span></span>
<p>The file `out.txt` contains the first two lines that were printed when we originally ran `python3 broken.py`, which are the lines that the script wanted to print. The error message from the interpreter was still printed to the terminal.</p>
</aside>
<aside class="footnote brackets" id="fn11" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">11</a><span class="fn-bracket">]</span></span>
<p>It will list any file ending in `.py` as long as the string before these last three characters contains at least one instance of the letter `e`.</p>
</aside>
<aside class="footnote brackets" id="fn12" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id12">12</a><span class="fn-bracket">]</span></span>
<p>It lists any file that ends in a two-character extension.</p>
</aside>
<aside class="footnote brackets" id="fn13" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id13">13</a><span class="fn-bracket">]</span></span>
<p>Most RE libraries, including Python’s, have been extended so that the patterns they match comprise more than the set of regular languages. For an excellent (and more comprehensive) introduction to Python’s `re` library, please read <a class="reference external" href="https://docs.python.org/3/howto/regex.html">A.M. Kuchling’s “Regular Expression HOWTO” document</a>.</p>
</aside>
<aside class="footnote brackets" id="fn14" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id14">14</a><span class="fn-bracket">]</span></span>
<p>The RE `[a-z]+` matches one word, but the string `this word` contains two words. The space character causes the RE to fail to match.</p>
</aside>
<aside class="footnote brackets" id="fn15" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">15</a><span class="fn-bracket">]</span></span>
<p>Not the string `2+3`, but strings like `23`, `223`, and any number containing a sequence of twos before a single concluding three.</p>
</aside>
<aside class="footnote brackets" id="fn16" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id16">16</a><span class="fn-bracket">]</span></span>
<p>The script `play.py` uses the built-in `input` function.</p>
</aside>
<aside class="footnote brackets" id="fn17" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id17">17</a><span class="fn-bracket">]</span></span>
<p>See Kuchling’s article referenced earlier for the lengthy explanation of this phenomenon.</p>
</aside>
<aside class="footnote brackets" id="fn18" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id18">18</a><span class="fn-bracket">]</span></span>
<p>You specify the RE as `\*`. You’ll get an error from the RE library if you responded with `*`, which is the metacharacter without any proceeding character to modify. The RE input to `play.py` is like specifying a Python raw string.</p>
</aside>
<aside class="footnote brackets" id="fn19" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id19">19</a><span class="fn-bracket">]</span></span>
<p>To see a full listing of the `re` library’s flags, see <a class="reference external" href="https://docs.python.org/3/library/re.html#contents-of-module-re">the description of the module contents</a>.</p>
</aside>
<aside class="footnote brackets" id="fn20" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id20">20</a><span class="fn-bracket">]</span></span>
<p>I’m taking you step-by-step through the development of a working RE, but it didn’t go this way when I did this work. I created what I thought might work, and then tried it on some examples. When it failed, I rethought the RE and tried again. Such is design work, as you know.</p>
</aside>
<aside class="footnote brackets" id="fn21" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id21">21</a><span class="fn-bracket">]</span></span>
<p>Take a moment to print `string.punctuation` and then consider which of these symbols you’d have to escape to put them in the RE. Thank goodness for formatted strings.</p>
</aside>
<aside class="footnote brackets" id="fn22" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id22">22</a><span class="fn-bracket">]</span></span>
<p>In Python, you specify that you want to print to stderr by setting the optional parameter `file` to `sys.stderr`. In other words, the `sys` module is where you find the definitions for `sys.stdin`, `sys.stdout`, and `sys.stderr`.</p>
</aside>
<aside class="footnote brackets" id="fn23" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id23">23</a><span class="fn-bracket">]</span></span>
<p>Where is the file size in the `ls` listing? It’s the fifth column. For example, `broken.py` is 416 bytes.</p>
</aside>
<aside class="footnote brackets" id="fn24" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id24">24</a><span class="fn-bracket">]</span></span>
<p>There are three groups of rwx bits with each file. Starting from the left, the second through fourth bits state the permissions of the file’s owner, which is typically the computer account under which the file was created. There’s a lot encoded in these file permission bits, which you can start reading about in the Wikipedia article on <a class="reference external" href="https://en.wikipedia.org/wiki/File-system_permissions">file-system permissions</a>.</p>
</aside>
<aside class="footnote brackets" id="fn25" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id25">25</a><span class="fn-bracket">]</span></span>
<p>To no longer allow a file to be executed, you’d type `chmod -x the_file`.</p>
</aside>
<aside class="footnote brackets" id="fn26" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id26">26</a><span class="fn-bracket">]</span></span>
<p>If the shell doesn’t recognize the start of an executable file as information on how to execute the file, you’ll probably get a cryptic error as it tries to interpret your file in an incorrect manner.</p>
</aside>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="chap12.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Chapter 12: Divide and Conquer</p>
      </div>
    </a>
    <a class="right-next"
       href="chap14.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Chapter 14: The Dream of Bug Fixing</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-mistakes-we-make-in-problem-solving">The mistakes we make in problem solving</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#our-problem-to-be-solved">Our problem-to-be-solved</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#from-the-gui-to-the-shell">From the GUI to the shell</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#understanding-paths">Understanding paths</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#from-paths-to-programs">From paths to programs</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#redirecting-inputs-and-outputs">Redirecting inputs and outputs</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#which-output">Which output?</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pattern-matching">Pattern matching</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#wildcards-in-the-shell">Wildcards in the shell</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#regular-expressions">Regular expressions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#finding-simple-words">Finding simple words</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#matching-metacharacters">Matching metacharacters</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#using-res">Using REs</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#finding-filenames">Finding filenames</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-promise-fulfilled">A promise fulfilled</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#python-re-extensions">Python RE extensions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#putting-it-all-together">Putting it all together</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#shell-pipes">Shell pipes</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#scripting-what-the-shell-did">Scripting what the shell did</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#concurrency">Concurrency</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#making-python32-look-like-python3">Making python32 look like python3</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Mike Smith
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2023 by Michael D. Smith. All rights reserved.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>